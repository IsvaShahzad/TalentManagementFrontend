import {
  require_querystring
} from "./chunk-MW66SHM6.js";
import {
  require_child_process
} from "./chunk-575GYA2V.js";
import {
  require_http
} from "./chunk-CYENVV2S.js";
import {
  require_https,
  require_url
} from "./chunk-PGQ4FOIU.js";
import {
  require_object_assign
} from "./chunk-2JAZTJT6.js";
import {
  require_browser,
  require_buffer,
  require_inherits_browser,
  require_safe_buffer,
  require_string_decoder
} from "./chunk-FANVQEQE.js";
import {
  require_events,
  require_os,
  require_path,
  require_util
} from "./chunk-3A3F4QLI.js";
import {
  require_fs
} from "./chunk-EJKCNYMO.js";
import {
  __commonJS,
  __require
} from "./chunk-H3AJBOWU.js";

// ../Server/node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "../Server/node_modules/mime/Mime.js"(exports, module) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
    }
    Mime.prototype.define = function(typeMap, force) {
      for (var type in typeMap) {
        var extensions = typeMap[type];
        for (var i = 0; i < extensions.length; i++) {
          var ext = extensions[i];
          if (ext[0] == "*") {
            extensions[i] = ext.substr(1);
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          this._extensions[type] = extensions[0];
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      var last = path.replace(/^.*[/\\]/, "").toLowerCase();
      var ext = last.replace(/^.*\./, "").toLowerCase();
      var hasPath = last.length < path.length;
      var hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module.exports = Mime;
  }
});

// ../Server/node_modules/mime/types/standard.json
var require_standard = __commonJS({
  "../Server/node_modules/mime/types/standard.json"(exports, module) {
    module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": ["woff"], "application/font-woff2": ["*woff2"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["*woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/webp": ["webp"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// ../Server/node_modules/mime/types/other.json
var require_other = __commonJS({
  "../Server/node_modules/mime/types/other.json"(exports, module) {
    module.exports = { "application/prs.cww": ["cww"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "*wmz", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// ../Server/node_modules/mime/index.js
var require_mime = __commonJS({
  "../Server/node_modules/mime/index.js"(exports, module) {
    "use strict";
    var Mime = require_Mime();
    module.exports = new Mime(require_standard(), require_other());
  }
});

// ../Server/node_modules/html-entities/lib/xml-entities.js
var require_xml_entities = __commonJS({
  "../Server/node_modules/html-entities/lib/xml-entities.js"(exports, module) {
    var ALPHA_INDEX = {
      "&lt": "<",
      "&gt": ">",
      "&quot": '"',
      "&apos": "'",
      "&amp": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&apos;": "'",
      "&amp;": "&"
    };
    var CHAR_INDEX = {
      60: "lt",
      62: "gt",
      34: "quot",
      39: "apos",
      38: "amp"
    };
    var CHAR_S_INDEX = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&apos;",
      "&": "&amp;"
    };
    function XmlEntities() {
    }
    XmlEntities.prototype.encode = function(str) {
      if (str.length === 0) {
        return "";
      }
      return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
      });
    };
    XmlEntities.encode = function(str) {
      return new XmlEntities().encode(str);
    };
    XmlEntities.prototype.decode = function(str) {
      if (str.length === 0) {
        return "";
      }
      return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === "#") {
          var code = s.charAt(2).toLowerCase() === "x" ? parseInt(s.substr(3), 16) : parseInt(s.substr(2));
          if (isNaN(code) || code < -32768 || code > 65535) {
            return "";
          }
          return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
      });
    };
    XmlEntities.decode = function(str) {
      return new XmlEntities().decode(str);
    };
    XmlEntities.prototype.encodeNonUTF = function(str) {
      var strLength = str.length;
      if (strLength === 0) {
        return "";
      }
      var result = "";
      var i = 0;
      while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
          result += "&" + alpha + ";";
          i++;
          continue;
        }
        if (c < 32 || c > 126) {
          result += "&#" + c + ";";
        } else {
          result += str.charAt(i);
        }
        i++;
      }
      return result;
    };
    XmlEntities.encodeNonUTF = function(str) {
      return new XmlEntities().encodeNonUTF(str);
    };
    XmlEntities.prototype.encodeNonASCII = function(str) {
      var strLenght = str.length;
      if (strLenght === 0) {
        return "";
      }
      var result = "";
      var i = 0;
      while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
          result += str[i++];
          continue;
        }
        result += "&#" + c + ";";
        i++;
      }
      return result;
    };
    XmlEntities.encodeNonASCII = function(str) {
      return new XmlEntities().encodeNonASCII(str);
    };
    module.exports = XmlEntities;
  }
});

// ../Server/node_modules/html-entities/lib/html4-entities.js
var require_html4_entities = __commonJS({
  "../Server/node_modules/html-entities/lib/html4-entities.js"(exports, module) {
    var HTML_ALPHA = ["apos", "nbsp", "iexcl", "cent", "pound", "curren", "yen", "brvbar", "sect", "uml", "copy", "ordf", "laquo", "not", "shy", "reg", "macr", "deg", "plusmn", "sup2", "sup3", "acute", "micro", "para", "middot", "cedil", "sup1", "ordm", "raquo", "frac14", "frac12", "frac34", "iquest", "Agrave", "Aacute", "Acirc", "Atilde", "Auml", "Aring", "Aelig", "Ccedil", "Egrave", "Eacute", "Ecirc", "Euml", "Igrave", "Iacute", "Icirc", "Iuml", "ETH", "Ntilde", "Ograve", "Oacute", "Ocirc", "Otilde", "Ouml", "times", "Oslash", "Ugrave", "Uacute", "Ucirc", "Uuml", "Yacute", "THORN", "szlig", "agrave", "aacute", "acirc", "atilde", "auml", "aring", "aelig", "ccedil", "egrave", "eacute", "ecirc", "euml", "igrave", "iacute", "icirc", "iuml", "eth", "ntilde", "ograve", "oacute", "ocirc", "otilde", "ouml", "divide", "Oslash", "ugrave", "uacute", "ucirc", "uuml", "yacute", "thorn", "yuml", "quot", "amp", "lt", "gt", "oelig", "oelig", "scaron", "scaron", "yuml", "circ", "tilde", "ensp", "emsp", "thinsp", "zwnj", "zwj", "lrm", "rlm", "ndash", "mdash", "lsquo", "rsquo", "sbquo", "ldquo", "rdquo", "bdquo", "dagger", "dagger", "permil", "lsaquo", "rsaquo", "euro", "fnof", "alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota", "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigma", "tau", "upsilon", "phi", "chi", "psi", "omega", "alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota", "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigmaf", "sigma", "tau", "upsilon", "phi", "chi", "psi", "omega", "thetasym", "upsih", "piv", "bull", "hellip", "prime", "prime", "oline", "frasl", "weierp", "image", "real", "trade", "alefsym", "larr", "uarr", "rarr", "darr", "harr", "crarr", "larr", "uarr", "rarr", "darr", "harr", "forall", "part", "exist", "empty", "nabla", "isin", "notin", "ni", "prod", "sum", "minus", "lowast", "radic", "prop", "infin", "ang", "and", "or", "cap", "cup", "int", "there4", "sim", "cong", "asymp", "ne", "equiv", "le", "ge", "sub", "sup", "nsub", "sube", "supe", "oplus", "otimes", "perp", "sdot", "lceil", "rceil", "lfloor", "rfloor", "lang", "rang", "loz", "spades", "clubs", "hearts", "diams"];
    var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];
    var alphaIndex = {};
    var numIndex = {};
    var i = 0;
    var length = HTML_ALPHA.length;
    while (i < length) {
      a = HTML_ALPHA[i];
      c = HTML_CODES[i];
      alphaIndex[a] = String.fromCharCode(c);
      numIndex[c] = a;
      i++;
    }
    var a;
    var c;
    function Html4Entities() {
    }
    Html4Entities.prototype.decode = function(str) {
      if (str.length === 0) {
        return "";
      }
      return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
          var code = entity.charAt(1).toLowerCase() === "x" ? parseInt(entity.substr(2), 16) : parseInt(entity.substr(1));
          if (!(isNaN(code) || code < -32768 || code > 65535)) {
            chr = String.fromCharCode(code);
          }
        } else {
          chr = alphaIndex[entity];
        }
        return chr || s;
      });
    };
    Html4Entities.decode = function(str) {
      return new Html4Entities().decode(str);
    };
    Html4Entities.prototype.encode = function(str) {
      var strLength = str.length;
      if (strLength === 0) {
        return "";
      }
      var result = "";
      var i2 = 0;
      while (i2 < strLength) {
        var alpha = numIndex[str.charCodeAt(i2)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i2);
        i2++;
      }
      return result;
    };
    Html4Entities.encode = function(str) {
      return new Html4Entities().encode(str);
    };
    Html4Entities.prototype.encodeNonUTF = function(str) {
      var strLength = str.length;
      if (strLength === 0) {
        return "";
      }
      var result = "";
      var i2 = 0;
      while (i2 < strLength) {
        var cc = str.charCodeAt(i2);
        var alpha = numIndex[cc];
        if (alpha) {
          result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
          result += "&#" + cc + ";";
        } else {
          result += str.charAt(i2);
        }
        i2++;
      }
      return result;
    };
    Html4Entities.encodeNonUTF = function(str) {
      return new Html4Entities().encodeNonUTF(str);
    };
    Html4Entities.prototype.encodeNonASCII = function(str) {
      var strLength = str.length;
      if (strLength === 0) {
        return "";
      }
      var result = "";
      var i2 = 0;
      while (i2 < strLength) {
        var c2 = str.charCodeAt(i2);
        if (c2 <= 255) {
          result += str[i2++];
          continue;
        }
        result += "&#" + c2 + ";";
        i2++;
      }
      return result;
    };
    Html4Entities.encodeNonASCII = function(str) {
      return new Html4Entities().encodeNonASCII(str);
    };
    module.exports = Html4Entities;
  }
});

// ../Server/node_modules/html-entities/lib/html5-entities.js
var require_html5_entities = __commonJS({
  "../Server/node_modules/html-entities/lib/html5-entities.js"(exports, module) {
    var ENTITIES = [["Aacute", [193]], ["aacute", [225]], ["Abreve", [258]], ["abreve", [259]], ["ac", [8766]], ["acd", [8767]], ["acE", [8766, 819]], ["Acirc", [194]], ["acirc", [226]], ["acute", [180]], ["Acy", [1040]], ["acy", [1072]], ["AElig", [198]], ["aelig", [230]], ["af", [8289]], ["Afr", [120068]], ["afr", [120094]], ["Agrave", [192]], ["agrave", [224]], ["alefsym", [8501]], ["aleph", [8501]], ["Alpha", [913]], ["alpha", [945]], ["Amacr", [256]], ["amacr", [257]], ["amalg", [10815]], ["amp", [38]], ["AMP", [38]], ["andand", [10837]], ["And", [10835]], ["and", [8743]], ["andd", [10844]], ["andslope", [10840]], ["andv", [10842]], ["ang", [8736]], ["ange", [10660]], ["angle", [8736]], ["angmsdaa", [10664]], ["angmsdab", [10665]], ["angmsdac", [10666]], ["angmsdad", [10667]], ["angmsdae", [10668]], ["angmsdaf", [10669]], ["angmsdag", [10670]], ["angmsdah", [10671]], ["angmsd", [8737]], ["angrt", [8735]], ["angrtvb", [8894]], ["angrtvbd", [10653]], ["angsph", [8738]], ["angst", [197]], ["angzarr", [9084]], ["Aogon", [260]], ["aogon", [261]], ["Aopf", [120120]], ["aopf", [120146]], ["apacir", [10863]], ["ap", [8776]], ["apE", [10864]], ["ape", [8778]], ["apid", [8779]], ["apos", [39]], ["ApplyFunction", [8289]], ["approx", [8776]], ["approxeq", [8778]], ["Aring", [197]], ["aring", [229]], ["Ascr", [119964]], ["ascr", [119990]], ["Assign", [8788]], ["ast", [42]], ["asymp", [8776]], ["asympeq", [8781]], ["Atilde", [195]], ["atilde", [227]], ["Auml", [196]], ["auml", [228]], ["awconint", [8755]], ["awint", [10769]], ["backcong", [8780]], ["backepsilon", [1014]], ["backprime", [8245]], ["backsim", [8765]], ["backsimeq", [8909]], ["Backslash", [8726]], ["Barv", [10983]], ["barvee", [8893]], ["barwed", [8965]], ["Barwed", [8966]], ["barwedge", [8965]], ["bbrk", [9141]], ["bbrktbrk", [9142]], ["bcong", [8780]], ["Bcy", [1041]], ["bcy", [1073]], ["bdquo", [8222]], ["becaus", [8757]], ["because", [8757]], ["Because", [8757]], ["bemptyv", [10672]], ["bepsi", [1014]], ["bernou", [8492]], ["Bernoullis", [8492]], ["Beta", [914]], ["beta", [946]], ["beth", [8502]], ["between", [8812]], ["Bfr", [120069]], ["bfr", [120095]], ["bigcap", [8898]], ["bigcirc", [9711]], ["bigcup", [8899]], ["bigodot", [10752]], ["bigoplus", [10753]], ["bigotimes", [10754]], ["bigsqcup", [10758]], ["bigstar", [9733]], ["bigtriangledown", [9661]], ["bigtriangleup", [9651]], ["biguplus", [10756]], ["bigvee", [8897]], ["bigwedge", [8896]], ["bkarow", [10509]], ["blacklozenge", [10731]], ["blacksquare", [9642]], ["blacktriangle", [9652]], ["blacktriangledown", [9662]], ["blacktriangleleft", [9666]], ["blacktriangleright", [9656]], ["blank", [9251]], ["blk12", [9618]], ["blk14", [9617]], ["blk34", [9619]], ["block", [9608]], ["bne", [61, 8421]], ["bnequiv", [8801, 8421]], ["bNot", [10989]], ["bnot", [8976]], ["Bopf", [120121]], ["bopf", [120147]], ["bot", [8869]], ["bottom", [8869]], ["bowtie", [8904]], ["boxbox", [10697]], ["boxdl", [9488]], ["boxdL", [9557]], ["boxDl", [9558]], ["boxDL", [9559]], ["boxdr", [9484]], ["boxdR", [9554]], ["boxDr", [9555]], ["boxDR", [9556]], ["boxh", [9472]], ["boxH", [9552]], ["boxhd", [9516]], ["boxHd", [9572]], ["boxhD", [9573]], ["boxHD", [9574]], ["boxhu", [9524]], ["boxHu", [9575]], ["boxhU", [9576]], ["boxHU", [9577]], ["boxminus", [8863]], ["boxplus", [8862]], ["boxtimes", [8864]], ["boxul", [9496]], ["boxuL", [9563]], ["boxUl", [9564]], ["boxUL", [9565]], ["boxur", [9492]], ["boxuR", [9560]], ["boxUr", [9561]], ["boxUR", [9562]], ["boxv", [9474]], ["boxV", [9553]], ["boxvh", [9532]], ["boxvH", [9578]], ["boxVh", [9579]], ["boxVH", [9580]], ["boxvl", [9508]], ["boxvL", [9569]], ["boxVl", [9570]], ["boxVL", [9571]], ["boxvr", [9500]], ["boxvR", [9566]], ["boxVr", [9567]], ["boxVR", [9568]], ["bprime", [8245]], ["breve", [728]], ["Breve", [728]], ["brvbar", [166]], ["bscr", [119991]], ["Bscr", [8492]], ["bsemi", [8271]], ["bsim", [8765]], ["bsime", [8909]], ["bsolb", [10693]], ["bsol", [92]], ["bsolhsub", [10184]], ["bull", [8226]], ["bullet", [8226]], ["bump", [8782]], ["bumpE", [10926]], ["bumpe", [8783]], ["Bumpeq", [8782]], ["bumpeq", [8783]], ["Cacute", [262]], ["cacute", [263]], ["capand", [10820]], ["capbrcup", [10825]], ["capcap", [10827]], ["cap", [8745]], ["Cap", [8914]], ["capcup", [10823]], ["capdot", [10816]], ["CapitalDifferentialD", [8517]], ["caps", [8745, 65024]], ["caret", [8257]], ["caron", [711]], ["Cayleys", [8493]], ["ccaps", [10829]], ["Ccaron", [268]], ["ccaron", [269]], ["Ccedil", [199]], ["ccedil", [231]], ["Ccirc", [264]], ["ccirc", [265]], ["Cconint", [8752]], ["ccups", [10828]], ["ccupssm", [10832]], ["Cdot", [266]], ["cdot", [267]], ["cedil", [184]], ["Cedilla", [184]], ["cemptyv", [10674]], ["cent", [162]], ["centerdot", [183]], ["CenterDot", [183]], ["cfr", [120096]], ["Cfr", [8493]], ["CHcy", [1063]], ["chcy", [1095]], ["check", [10003]], ["checkmark", [10003]], ["Chi", [935]], ["chi", [967]], ["circ", [710]], ["circeq", [8791]], ["circlearrowleft", [8634]], ["circlearrowright", [8635]], ["circledast", [8859]], ["circledcirc", [8858]], ["circleddash", [8861]], ["CircleDot", [8857]], ["circledR", [174]], ["circledS", [9416]], ["CircleMinus", [8854]], ["CirclePlus", [8853]], ["CircleTimes", [8855]], ["cir", [9675]], ["cirE", [10691]], ["cire", [8791]], ["cirfnint", [10768]], ["cirmid", [10991]], ["cirscir", [10690]], ["ClockwiseContourIntegral", [8754]], ["CloseCurlyDoubleQuote", [8221]], ["CloseCurlyQuote", [8217]], ["clubs", [9827]], ["clubsuit", [9827]], ["colon", [58]], ["Colon", [8759]], ["Colone", [10868]], ["colone", [8788]], ["coloneq", [8788]], ["comma", [44]], ["commat", [64]], ["comp", [8705]], ["compfn", [8728]], ["complement", [8705]], ["complexes", [8450]], ["cong", [8773]], ["congdot", [10861]], ["Congruent", [8801]], ["conint", [8750]], ["Conint", [8751]], ["ContourIntegral", [8750]], ["copf", [120148]], ["Copf", [8450]], ["coprod", [8720]], ["Coproduct", [8720]], ["copy", [169]], ["COPY", [169]], ["copysr", [8471]], ["CounterClockwiseContourIntegral", [8755]], ["crarr", [8629]], ["cross", [10007]], ["Cross", [10799]], ["Cscr", [119966]], ["cscr", [119992]], ["csub", [10959]], ["csube", [10961]], ["csup", [10960]], ["csupe", [10962]], ["ctdot", [8943]], ["cudarrl", [10552]], ["cudarrr", [10549]], ["cuepr", [8926]], ["cuesc", [8927]], ["cularr", [8630]], ["cularrp", [10557]], ["cupbrcap", [10824]], ["cupcap", [10822]], ["CupCap", [8781]], ["cup", [8746]], ["Cup", [8915]], ["cupcup", [10826]], ["cupdot", [8845]], ["cupor", [10821]], ["cups", [8746, 65024]], ["curarr", [8631]], ["curarrm", [10556]], ["curlyeqprec", [8926]], ["curlyeqsucc", [8927]], ["curlyvee", [8910]], ["curlywedge", [8911]], ["curren", [164]], ["curvearrowleft", [8630]], ["curvearrowright", [8631]], ["cuvee", [8910]], ["cuwed", [8911]], ["cwconint", [8754]], ["cwint", [8753]], ["cylcty", [9005]], ["dagger", [8224]], ["Dagger", [8225]], ["daleth", [8504]], ["darr", [8595]], ["Darr", [8609]], ["dArr", [8659]], ["dash", [8208]], ["Dashv", [10980]], ["dashv", [8867]], ["dbkarow", [10511]], ["dblac", [733]], ["Dcaron", [270]], ["dcaron", [271]], ["Dcy", [1044]], ["dcy", [1076]], ["ddagger", [8225]], ["ddarr", [8650]], ["DD", [8517]], ["dd", [8518]], ["DDotrahd", [10513]], ["ddotseq", [10871]], ["deg", [176]], ["Del", [8711]], ["Delta", [916]], ["delta", [948]], ["demptyv", [10673]], ["dfisht", [10623]], ["Dfr", [120071]], ["dfr", [120097]], ["dHar", [10597]], ["dharl", [8643]], ["dharr", [8642]], ["DiacriticalAcute", [180]], ["DiacriticalDot", [729]], ["DiacriticalDoubleAcute", [733]], ["DiacriticalGrave", [96]], ["DiacriticalTilde", [732]], ["diam", [8900]], ["diamond", [8900]], ["Diamond", [8900]], ["diamondsuit", [9830]], ["diams", [9830]], ["die", [168]], ["DifferentialD", [8518]], ["digamma", [989]], ["disin", [8946]], ["div", [247]], ["divide", [247]], ["divideontimes", [8903]], ["divonx", [8903]], ["DJcy", [1026]], ["djcy", [1106]], ["dlcorn", [8990]], ["dlcrop", [8973]], ["dollar", [36]], ["Dopf", [120123]], ["dopf", [120149]], ["Dot", [168]], ["dot", [729]], ["DotDot", [8412]], ["doteq", [8784]], ["doteqdot", [8785]], ["DotEqual", [8784]], ["dotminus", [8760]], ["dotplus", [8724]], ["dotsquare", [8865]], ["doublebarwedge", [8966]], ["DoubleContourIntegral", [8751]], ["DoubleDot", [168]], ["DoubleDownArrow", [8659]], ["DoubleLeftArrow", [8656]], ["DoubleLeftRightArrow", [8660]], ["DoubleLeftTee", [10980]], ["DoubleLongLeftArrow", [10232]], ["DoubleLongLeftRightArrow", [10234]], ["DoubleLongRightArrow", [10233]], ["DoubleRightArrow", [8658]], ["DoubleRightTee", [8872]], ["DoubleUpArrow", [8657]], ["DoubleUpDownArrow", [8661]], ["DoubleVerticalBar", [8741]], ["DownArrowBar", [10515]], ["downarrow", [8595]], ["DownArrow", [8595]], ["Downarrow", [8659]], ["DownArrowUpArrow", [8693]], ["DownBreve", [785]], ["downdownarrows", [8650]], ["downharpoonleft", [8643]], ["downharpoonright", [8642]], ["DownLeftRightVector", [10576]], ["DownLeftTeeVector", [10590]], ["DownLeftVectorBar", [10582]], ["DownLeftVector", [8637]], ["DownRightTeeVector", [10591]], ["DownRightVectorBar", [10583]], ["DownRightVector", [8641]], ["DownTeeArrow", [8615]], ["DownTee", [8868]], ["drbkarow", [10512]], ["drcorn", [8991]], ["drcrop", [8972]], ["Dscr", [119967]], ["dscr", [119993]], ["DScy", [1029]], ["dscy", [1109]], ["dsol", [10742]], ["Dstrok", [272]], ["dstrok", [273]], ["dtdot", [8945]], ["dtri", [9663]], ["dtrif", [9662]], ["duarr", [8693]], ["duhar", [10607]], ["dwangle", [10662]], ["DZcy", [1039]], ["dzcy", [1119]], ["dzigrarr", [10239]], ["Eacute", [201]], ["eacute", [233]], ["easter", [10862]], ["Ecaron", [282]], ["ecaron", [283]], ["Ecirc", [202]], ["ecirc", [234]], ["ecir", [8790]], ["ecolon", [8789]], ["Ecy", [1069]], ["ecy", [1101]], ["eDDot", [10871]], ["Edot", [278]], ["edot", [279]], ["eDot", [8785]], ["ee", [8519]], ["efDot", [8786]], ["Efr", [120072]], ["efr", [120098]], ["eg", [10906]], ["Egrave", [200]], ["egrave", [232]], ["egs", [10902]], ["egsdot", [10904]], ["el", [10905]], ["Element", [8712]], ["elinters", [9191]], ["ell", [8467]], ["els", [10901]], ["elsdot", [10903]], ["Emacr", [274]], ["emacr", [275]], ["empty", [8709]], ["emptyset", [8709]], ["EmptySmallSquare", [9723]], ["emptyv", [8709]], ["EmptyVerySmallSquare", [9643]], ["emsp13", [8196]], ["emsp14", [8197]], ["emsp", [8195]], ["ENG", [330]], ["eng", [331]], ["ensp", [8194]], ["Eogon", [280]], ["eogon", [281]], ["Eopf", [120124]], ["eopf", [120150]], ["epar", [8917]], ["eparsl", [10723]], ["eplus", [10865]], ["epsi", [949]], ["Epsilon", [917]], ["epsilon", [949]], ["epsiv", [1013]], ["eqcirc", [8790]], ["eqcolon", [8789]], ["eqsim", [8770]], ["eqslantgtr", [10902]], ["eqslantless", [10901]], ["Equal", [10869]], ["equals", [61]], ["EqualTilde", [8770]], ["equest", [8799]], ["Equilibrium", [8652]], ["equiv", [8801]], ["equivDD", [10872]], ["eqvparsl", [10725]], ["erarr", [10609]], ["erDot", [8787]], ["escr", [8495]], ["Escr", [8496]], ["esdot", [8784]], ["Esim", [10867]], ["esim", [8770]], ["Eta", [919]], ["eta", [951]], ["ETH", [208]], ["eth", [240]], ["Euml", [203]], ["euml", [235]], ["euro", [8364]], ["excl", [33]], ["exist", [8707]], ["Exists", [8707]], ["expectation", [8496]], ["exponentiale", [8519]], ["ExponentialE", [8519]], ["fallingdotseq", [8786]], ["Fcy", [1060]], ["fcy", [1092]], ["female", [9792]], ["ffilig", [64259]], ["fflig", [64256]], ["ffllig", [64260]], ["Ffr", [120073]], ["ffr", [120099]], ["filig", [64257]], ["FilledSmallSquare", [9724]], ["FilledVerySmallSquare", [9642]], ["fjlig", [102, 106]], ["flat", [9837]], ["fllig", [64258]], ["fltns", [9649]], ["fnof", [402]], ["Fopf", [120125]], ["fopf", [120151]], ["forall", [8704]], ["ForAll", [8704]], ["fork", [8916]], ["forkv", [10969]], ["Fouriertrf", [8497]], ["fpartint", [10765]], ["frac12", [189]], ["frac13", [8531]], ["frac14", [188]], ["frac15", [8533]], ["frac16", [8537]], ["frac18", [8539]], ["frac23", [8532]], ["frac25", [8534]], ["frac34", [190]], ["frac35", [8535]], ["frac38", [8540]], ["frac45", [8536]], ["frac56", [8538]], ["frac58", [8541]], ["frac78", [8542]], ["frasl", [8260]], ["frown", [8994]], ["fscr", [119995]], ["Fscr", [8497]], ["gacute", [501]], ["Gamma", [915]], ["gamma", [947]], ["Gammad", [988]], ["gammad", [989]], ["gap", [10886]], ["Gbreve", [286]], ["gbreve", [287]], ["Gcedil", [290]], ["Gcirc", [284]], ["gcirc", [285]], ["Gcy", [1043]], ["gcy", [1075]], ["Gdot", [288]], ["gdot", [289]], ["ge", [8805]], ["gE", [8807]], ["gEl", [10892]], ["gel", [8923]], ["geq", [8805]], ["geqq", [8807]], ["geqslant", [10878]], ["gescc", [10921]], ["ges", [10878]], ["gesdot", [10880]], ["gesdoto", [10882]], ["gesdotol", [10884]], ["gesl", [8923, 65024]], ["gesles", [10900]], ["Gfr", [120074]], ["gfr", [120100]], ["gg", [8811]], ["Gg", [8921]], ["ggg", [8921]], ["gimel", [8503]], ["GJcy", [1027]], ["gjcy", [1107]], ["gla", [10917]], ["gl", [8823]], ["glE", [10898]], ["glj", [10916]], ["gnap", [10890]], ["gnapprox", [10890]], ["gne", [10888]], ["gnE", [8809]], ["gneq", [10888]], ["gneqq", [8809]], ["gnsim", [8935]], ["Gopf", [120126]], ["gopf", [120152]], ["grave", [96]], ["GreaterEqual", [8805]], ["GreaterEqualLess", [8923]], ["GreaterFullEqual", [8807]], ["GreaterGreater", [10914]], ["GreaterLess", [8823]], ["GreaterSlantEqual", [10878]], ["GreaterTilde", [8819]], ["Gscr", [119970]], ["gscr", [8458]], ["gsim", [8819]], ["gsime", [10894]], ["gsiml", [10896]], ["gtcc", [10919]], ["gtcir", [10874]], ["gt", [62]], ["GT", [62]], ["Gt", [8811]], ["gtdot", [8919]], ["gtlPar", [10645]], ["gtquest", [10876]], ["gtrapprox", [10886]], ["gtrarr", [10616]], ["gtrdot", [8919]], ["gtreqless", [8923]], ["gtreqqless", [10892]], ["gtrless", [8823]], ["gtrsim", [8819]], ["gvertneqq", [8809, 65024]], ["gvnE", [8809, 65024]], ["Hacek", [711]], ["hairsp", [8202]], ["half", [189]], ["hamilt", [8459]], ["HARDcy", [1066]], ["hardcy", [1098]], ["harrcir", [10568]], ["harr", [8596]], ["hArr", [8660]], ["harrw", [8621]], ["Hat", [94]], ["hbar", [8463]], ["Hcirc", [292]], ["hcirc", [293]], ["hearts", [9829]], ["heartsuit", [9829]], ["hellip", [8230]], ["hercon", [8889]], ["hfr", [120101]], ["Hfr", [8460]], ["HilbertSpace", [8459]], ["hksearow", [10533]], ["hkswarow", [10534]], ["hoarr", [8703]], ["homtht", [8763]], ["hookleftarrow", [8617]], ["hookrightarrow", [8618]], ["hopf", [120153]], ["Hopf", [8461]], ["horbar", [8213]], ["HorizontalLine", [9472]], ["hscr", [119997]], ["Hscr", [8459]], ["hslash", [8463]], ["Hstrok", [294]], ["hstrok", [295]], ["HumpDownHump", [8782]], ["HumpEqual", [8783]], ["hybull", [8259]], ["hyphen", [8208]], ["Iacute", [205]], ["iacute", [237]], ["ic", [8291]], ["Icirc", [206]], ["icirc", [238]], ["Icy", [1048]], ["icy", [1080]], ["Idot", [304]], ["IEcy", [1045]], ["iecy", [1077]], ["iexcl", [161]], ["iff", [8660]], ["ifr", [120102]], ["Ifr", [8465]], ["Igrave", [204]], ["igrave", [236]], ["ii", [8520]], ["iiiint", [10764]], ["iiint", [8749]], ["iinfin", [10716]], ["iiota", [8489]], ["IJlig", [306]], ["ijlig", [307]], ["Imacr", [298]], ["imacr", [299]], ["image", [8465]], ["ImaginaryI", [8520]], ["imagline", [8464]], ["imagpart", [8465]], ["imath", [305]], ["Im", [8465]], ["imof", [8887]], ["imped", [437]], ["Implies", [8658]], ["incare", [8453]], ["in", [8712]], ["infin", [8734]], ["infintie", [10717]], ["inodot", [305]], ["intcal", [8890]], ["int", [8747]], ["Int", [8748]], ["integers", [8484]], ["Integral", [8747]], ["intercal", [8890]], ["Intersection", [8898]], ["intlarhk", [10775]], ["intprod", [10812]], ["InvisibleComma", [8291]], ["InvisibleTimes", [8290]], ["IOcy", [1025]], ["iocy", [1105]], ["Iogon", [302]], ["iogon", [303]], ["Iopf", [120128]], ["iopf", [120154]], ["Iota", [921]], ["iota", [953]], ["iprod", [10812]], ["iquest", [191]], ["iscr", [119998]], ["Iscr", [8464]], ["isin", [8712]], ["isindot", [8949]], ["isinE", [8953]], ["isins", [8948]], ["isinsv", [8947]], ["isinv", [8712]], ["it", [8290]], ["Itilde", [296]], ["itilde", [297]], ["Iukcy", [1030]], ["iukcy", [1110]], ["Iuml", [207]], ["iuml", [239]], ["Jcirc", [308]], ["jcirc", [309]], ["Jcy", [1049]], ["jcy", [1081]], ["Jfr", [120077]], ["jfr", [120103]], ["jmath", [567]], ["Jopf", [120129]], ["jopf", [120155]], ["Jscr", [119973]], ["jscr", [119999]], ["Jsercy", [1032]], ["jsercy", [1112]], ["Jukcy", [1028]], ["jukcy", [1108]], ["Kappa", [922]], ["kappa", [954]], ["kappav", [1008]], ["Kcedil", [310]], ["kcedil", [311]], ["Kcy", [1050]], ["kcy", [1082]], ["Kfr", [120078]], ["kfr", [120104]], ["kgreen", [312]], ["KHcy", [1061]], ["khcy", [1093]], ["KJcy", [1036]], ["kjcy", [1116]], ["Kopf", [120130]], ["kopf", [120156]], ["Kscr", [119974]], ["kscr", [12e4]], ["lAarr", [8666]], ["Lacute", [313]], ["lacute", [314]], ["laemptyv", [10676]], ["lagran", [8466]], ["Lambda", [923]], ["lambda", [955]], ["lang", [10216]], ["Lang", [10218]], ["langd", [10641]], ["langle", [10216]], ["lap", [10885]], ["Laplacetrf", [8466]], ["laquo", [171]], ["larrb", [8676]], ["larrbfs", [10527]], ["larr", [8592]], ["Larr", [8606]], ["lArr", [8656]], ["larrfs", [10525]], ["larrhk", [8617]], ["larrlp", [8619]], ["larrpl", [10553]], ["larrsim", [10611]], ["larrtl", [8610]], ["latail", [10521]], ["lAtail", [10523]], ["lat", [10923]], ["late", [10925]], ["lates", [10925, 65024]], ["lbarr", [10508]], ["lBarr", [10510]], ["lbbrk", [10098]], ["lbrace", [123]], ["lbrack", [91]], ["lbrke", [10635]], ["lbrksld", [10639]], ["lbrkslu", [10637]], ["Lcaron", [317]], ["lcaron", [318]], ["Lcedil", [315]], ["lcedil", [316]], ["lceil", [8968]], ["lcub", [123]], ["Lcy", [1051]], ["lcy", [1083]], ["ldca", [10550]], ["ldquo", [8220]], ["ldquor", [8222]], ["ldrdhar", [10599]], ["ldrushar", [10571]], ["ldsh", [8626]], ["le", [8804]], ["lE", [8806]], ["LeftAngleBracket", [10216]], ["LeftArrowBar", [8676]], ["leftarrow", [8592]], ["LeftArrow", [8592]], ["Leftarrow", [8656]], ["LeftArrowRightArrow", [8646]], ["leftarrowtail", [8610]], ["LeftCeiling", [8968]], ["LeftDoubleBracket", [10214]], ["LeftDownTeeVector", [10593]], ["LeftDownVectorBar", [10585]], ["LeftDownVector", [8643]], ["LeftFloor", [8970]], ["leftharpoondown", [8637]], ["leftharpoonup", [8636]], ["leftleftarrows", [8647]], ["leftrightarrow", [8596]], ["LeftRightArrow", [8596]], ["Leftrightarrow", [8660]], ["leftrightarrows", [8646]], ["leftrightharpoons", [8651]], ["leftrightsquigarrow", [8621]], ["LeftRightVector", [10574]], ["LeftTeeArrow", [8612]], ["LeftTee", [8867]], ["LeftTeeVector", [10586]], ["leftthreetimes", [8907]], ["LeftTriangleBar", [10703]], ["LeftTriangle", [8882]], ["LeftTriangleEqual", [8884]], ["LeftUpDownVector", [10577]], ["LeftUpTeeVector", [10592]], ["LeftUpVectorBar", [10584]], ["LeftUpVector", [8639]], ["LeftVectorBar", [10578]], ["LeftVector", [8636]], ["lEg", [10891]], ["leg", [8922]], ["leq", [8804]], ["leqq", [8806]], ["leqslant", [10877]], ["lescc", [10920]], ["les", [10877]], ["lesdot", [10879]], ["lesdoto", [10881]], ["lesdotor", [10883]], ["lesg", [8922, 65024]], ["lesges", [10899]], ["lessapprox", [10885]], ["lessdot", [8918]], ["lesseqgtr", [8922]], ["lesseqqgtr", [10891]], ["LessEqualGreater", [8922]], ["LessFullEqual", [8806]], ["LessGreater", [8822]], ["lessgtr", [8822]], ["LessLess", [10913]], ["lesssim", [8818]], ["LessSlantEqual", [10877]], ["LessTilde", [8818]], ["lfisht", [10620]], ["lfloor", [8970]], ["Lfr", [120079]], ["lfr", [120105]], ["lg", [8822]], ["lgE", [10897]], ["lHar", [10594]], ["lhard", [8637]], ["lharu", [8636]], ["lharul", [10602]], ["lhblk", [9604]], ["LJcy", [1033]], ["ljcy", [1113]], ["llarr", [8647]], ["ll", [8810]], ["Ll", [8920]], ["llcorner", [8990]], ["Lleftarrow", [8666]], ["llhard", [10603]], ["lltri", [9722]], ["Lmidot", [319]], ["lmidot", [320]], ["lmoustache", [9136]], ["lmoust", [9136]], ["lnap", [10889]], ["lnapprox", [10889]], ["lne", [10887]], ["lnE", [8808]], ["lneq", [10887]], ["lneqq", [8808]], ["lnsim", [8934]], ["loang", [10220]], ["loarr", [8701]], ["lobrk", [10214]], ["longleftarrow", [10229]], ["LongLeftArrow", [10229]], ["Longleftarrow", [10232]], ["longleftrightarrow", [10231]], ["LongLeftRightArrow", [10231]], ["Longleftrightarrow", [10234]], ["longmapsto", [10236]], ["longrightarrow", [10230]], ["LongRightArrow", [10230]], ["Longrightarrow", [10233]], ["looparrowleft", [8619]], ["looparrowright", [8620]], ["lopar", [10629]], ["Lopf", [120131]], ["lopf", [120157]], ["loplus", [10797]], ["lotimes", [10804]], ["lowast", [8727]], ["lowbar", [95]], ["LowerLeftArrow", [8601]], ["LowerRightArrow", [8600]], ["loz", [9674]], ["lozenge", [9674]], ["lozf", [10731]], ["lpar", [40]], ["lparlt", [10643]], ["lrarr", [8646]], ["lrcorner", [8991]], ["lrhar", [8651]], ["lrhard", [10605]], ["lrm", [8206]], ["lrtri", [8895]], ["lsaquo", [8249]], ["lscr", [120001]], ["Lscr", [8466]], ["lsh", [8624]], ["Lsh", [8624]], ["lsim", [8818]], ["lsime", [10893]], ["lsimg", [10895]], ["lsqb", [91]], ["lsquo", [8216]], ["lsquor", [8218]], ["Lstrok", [321]], ["lstrok", [322]], ["ltcc", [10918]], ["ltcir", [10873]], ["lt", [60]], ["LT", [60]], ["Lt", [8810]], ["ltdot", [8918]], ["lthree", [8907]], ["ltimes", [8905]], ["ltlarr", [10614]], ["ltquest", [10875]], ["ltri", [9667]], ["ltrie", [8884]], ["ltrif", [9666]], ["ltrPar", [10646]], ["lurdshar", [10570]], ["luruhar", [10598]], ["lvertneqq", [8808, 65024]], ["lvnE", [8808, 65024]], ["macr", [175]], ["male", [9794]], ["malt", [10016]], ["maltese", [10016]], ["Map", [10501]], ["map", [8614]], ["mapsto", [8614]], ["mapstodown", [8615]], ["mapstoleft", [8612]], ["mapstoup", [8613]], ["marker", [9646]], ["mcomma", [10793]], ["Mcy", [1052]], ["mcy", [1084]], ["mdash", [8212]], ["mDDot", [8762]], ["measuredangle", [8737]], ["MediumSpace", [8287]], ["Mellintrf", [8499]], ["Mfr", [120080]], ["mfr", [120106]], ["mho", [8487]], ["micro", [181]], ["midast", [42]], ["midcir", [10992]], ["mid", [8739]], ["middot", [183]], ["minusb", [8863]], ["minus", [8722]], ["minusd", [8760]], ["minusdu", [10794]], ["MinusPlus", [8723]], ["mlcp", [10971]], ["mldr", [8230]], ["mnplus", [8723]], ["models", [8871]], ["Mopf", [120132]], ["mopf", [120158]], ["mp", [8723]], ["mscr", [120002]], ["Mscr", [8499]], ["mstpos", [8766]], ["Mu", [924]], ["mu", [956]], ["multimap", [8888]], ["mumap", [8888]], ["nabla", [8711]], ["Nacute", [323]], ["nacute", [324]], ["nang", [8736, 8402]], ["nap", [8777]], ["napE", [10864, 824]], ["napid", [8779, 824]], ["napos", [329]], ["napprox", [8777]], ["natural", [9838]], ["naturals", [8469]], ["natur", [9838]], ["nbsp", [160]], ["nbump", [8782, 824]], ["nbumpe", [8783, 824]], ["ncap", [10819]], ["Ncaron", [327]], ["ncaron", [328]], ["Ncedil", [325]], ["ncedil", [326]], ["ncong", [8775]], ["ncongdot", [10861, 824]], ["ncup", [10818]], ["Ncy", [1053]], ["ncy", [1085]], ["ndash", [8211]], ["nearhk", [10532]], ["nearr", [8599]], ["neArr", [8663]], ["nearrow", [8599]], ["ne", [8800]], ["nedot", [8784, 824]], ["NegativeMediumSpace", [8203]], ["NegativeThickSpace", [8203]], ["NegativeThinSpace", [8203]], ["NegativeVeryThinSpace", [8203]], ["nequiv", [8802]], ["nesear", [10536]], ["nesim", [8770, 824]], ["NestedGreaterGreater", [8811]], ["NestedLessLess", [8810]], ["nexist", [8708]], ["nexists", [8708]], ["Nfr", [120081]], ["nfr", [120107]], ["ngE", [8807, 824]], ["nge", [8817]], ["ngeq", [8817]], ["ngeqq", [8807, 824]], ["ngeqslant", [10878, 824]], ["nges", [10878, 824]], ["nGg", [8921, 824]], ["ngsim", [8821]], ["nGt", [8811, 8402]], ["ngt", [8815]], ["ngtr", [8815]], ["nGtv", [8811, 824]], ["nharr", [8622]], ["nhArr", [8654]], ["nhpar", [10994]], ["ni", [8715]], ["nis", [8956]], ["nisd", [8954]], ["niv", [8715]], ["NJcy", [1034]], ["njcy", [1114]], ["nlarr", [8602]], ["nlArr", [8653]], ["nldr", [8229]], ["nlE", [8806, 824]], ["nle", [8816]], ["nleftarrow", [8602]], ["nLeftarrow", [8653]], ["nleftrightarrow", [8622]], ["nLeftrightarrow", [8654]], ["nleq", [8816]], ["nleqq", [8806, 824]], ["nleqslant", [10877, 824]], ["nles", [10877, 824]], ["nless", [8814]], ["nLl", [8920, 824]], ["nlsim", [8820]], ["nLt", [8810, 8402]], ["nlt", [8814]], ["nltri", [8938]], ["nltrie", [8940]], ["nLtv", [8810, 824]], ["nmid", [8740]], ["NoBreak", [8288]], ["NonBreakingSpace", [160]], ["nopf", [120159]], ["Nopf", [8469]], ["Not", [10988]], ["not", [172]], ["NotCongruent", [8802]], ["NotCupCap", [8813]], ["NotDoubleVerticalBar", [8742]], ["NotElement", [8713]], ["NotEqual", [8800]], ["NotEqualTilde", [8770, 824]], ["NotExists", [8708]], ["NotGreater", [8815]], ["NotGreaterEqual", [8817]], ["NotGreaterFullEqual", [8807, 824]], ["NotGreaterGreater", [8811, 824]], ["NotGreaterLess", [8825]], ["NotGreaterSlantEqual", [10878, 824]], ["NotGreaterTilde", [8821]], ["NotHumpDownHump", [8782, 824]], ["NotHumpEqual", [8783, 824]], ["notin", [8713]], ["notindot", [8949, 824]], ["notinE", [8953, 824]], ["notinva", [8713]], ["notinvb", [8951]], ["notinvc", [8950]], ["NotLeftTriangleBar", [10703, 824]], ["NotLeftTriangle", [8938]], ["NotLeftTriangleEqual", [8940]], ["NotLess", [8814]], ["NotLessEqual", [8816]], ["NotLessGreater", [8824]], ["NotLessLess", [8810, 824]], ["NotLessSlantEqual", [10877, 824]], ["NotLessTilde", [8820]], ["NotNestedGreaterGreater", [10914, 824]], ["NotNestedLessLess", [10913, 824]], ["notni", [8716]], ["notniva", [8716]], ["notnivb", [8958]], ["notnivc", [8957]], ["NotPrecedes", [8832]], ["NotPrecedesEqual", [10927, 824]], ["NotPrecedesSlantEqual", [8928]], ["NotReverseElement", [8716]], ["NotRightTriangleBar", [10704, 824]], ["NotRightTriangle", [8939]], ["NotRightTriangleEqual", [8941]], ["NotSquareSubset", [8847, 824]], ["NotSquareSubsetEqual", [8930]], ["NotSquareSuperset", [8848, 824]], ["NotSquareSupersetEqual", [8931]], ["NotSubset", [8834, 8402]], ["NotSubsetEqual", [8840]], ["NotSucceeds", [8833]], ["NotSucceedsEqual", [10928, 824]], ["NotSucceedsSlantEqual", [8929]], ["NotSucceedsTilde", [8831, 824]], ["NotSuperset", [8835, 8402]], ["NotSupersetEqual", [8841]], ["NotTilde", [8769]], ["NotTildeEqual", [8772]], ["NotTildeFullEqual", [8775]], ["NotTildeTilde", [8777]], ["NotVerticalBar", [8740]], ["nparallel", [8742]], ["npar", [8742]], ["nparsl", [11005, 8421]], ["npart", [8706, 824]], ["npolint", [10772]], ["npr", [8832]], ["nprcue", [8928]], ["nprec", [8832]], ["npreceq", [10927, 824]], ["npre", [10927, 824]], ["nrarrc", [10547, 824]], ["nrarr", [8603]], ["nrArr", [8655]], ["nrarrw", [8605, 824]], ["nrightarrow", [8603]], ["nRightarrow", [8655]], ["nrtri", [8939]], ["nrtrie", [8941]], ["nsc", [8833]], ["nsccue", [8929]], ["nsce", [10928, 824]], ["Nscr", [119977]], ["nscr", [120003]], ["nshortmid", [8740]], ["nshortparallel", [8742]], ["nsim", [8769]], ["nsime", [8772]], ["nsimeq", [8772]], ["nsmid", [8740]], ["nspar", [8742]], ["nsqsube", [8930]], ["nsqsupe", [8931]], ["nsub", [8836]], ["nsubE", [10949, 824]], ["nsube", [8840]], ["nsubset", [8834, 8402]], ["nsubseteq", [8840]], ["nsubseteqq", [10949, 824]], ["nsucc", [8833]], ["nsucceq", [10928, 824]], ["nsup", [8837]], ["nsupE", [10950, 824]], ["nsupe", [8841]], ["nsupset", [8835, 8402]], ["nsupseteq", [8841]], ["nsupseteqq", [10950, 824]], ["ntgl", [8825]], ["Ntilde", [209]], ["ntilde", [241]], ["ntlg", [8824]], ["ntriangleleft", [8938]], ["ntrianglelefteq", [8940]], ["ntriangleright", [8939]], ["ntrianglerighteq", [8941]], ["Nu", [925]], ["nu", [957]], ["num", [35]], ["numero", [8470]], ["numsp", [8199]], ["nvap", [8781, 8402]], ["nvdash", [8876]], ["nvDash", [8877]], ["nVdash", [8878]], ["nVDash", [8879]], ["nvge", [8805, 8402]], ["nvgt", [62, 8402]], ["nvHarr", [10500]], ["nvinfin", [10718]], ["nvlArr", [10498]], ["nvle", [8804, 8402]], ["nvlt", [60, 8402]], ["nvltrie", [8884, 8402]], ["nvrArr", [10499]], ["nvrtrie", [8885, 8402]], ["nvsim", [8764, 8402]], ["nwarhk", [10531]], ["nwarr", [8598]], ["nwArr", [8662]], ["nwarrow", [8598]], ["nwnear", [10535]], ["Oacute", [211]], ["oacute", [243]], ["oast", [8859]], ["Ocirc", [212]], ["ocirc", [244]], ["ocir", [8858]], ["Ocy", [1054]], ["ocy", [1086]], ["odash", [8861]], ["Odblac", [336]], ["odblac", [337]], ["odiv", [10808]], ["odot", [8857]], ["odsold", [10684]], ["OElig", [338]], ["oelig", [339]], ["ofcir", [10687]], ["Ofr", [120082]], ["ofr", [120108]], ["ogon", [731]], ["Ograve", [210]], ["ograve", [242]], ["ogt", [10689]], ["ohbar", [10677]], ["ohm", [937]], ["oint", [8750]], ["olarr", [8634]], ["olcir", [10686]], ["olcross", [10683]], ["oline", [8254]], ["olt", [10688]], ["Omacr", [332]], ["omacr", [333]], ["Omega", [937]], ["omega", [969]], ["Omicron", [927]], ["omicron", [959]], ["omid", [10678]], ["ominus", [8854]], ["Oopf", [120134]], ["oopf", [120160]], ["opar", [10679]], ["OpenCurlyDoubleQuote", [8220]], ["OpenCurlyQuote", [8216]], ["operp", [10681]], ["oplus", [8853]], ["orarr", [8635]], ["Or", [10836]], ["or", [8744]], ["ord", [10845]], ["order", [8500]], ["orderof", [8500]], ["ordf", [170]], ["ordm", [186]], ["origof", [8886]], ["oror", [10838]], ["orslope", [10839]], ["orv", [10843]], ["oS", [9416]], ["Oscr", [119978]], ["oscr", [8500]], ["Oslash", [216]], ["oslash", [248]], ["osol", [8856]], ["Otilde", [213]], ["otilde", [245]], ["otimesas", [10806]], ["Otimes", [10807]], ["otimes", [8855]], ["Ouml", [214]], ["ouml", [246]], ["ovbar", [9021]], ["OverBar", [8254]], ["OverBrace", [9182]], ["OverBracket", [9140]], ["OverParenthesis", [9180]], ["para", [182]], ["parallel", [8741]], ["par", [8741]], ["parsim", [10995]], ["parsl", [11005]], ["part", [8706]], ["PartialD", [8706]], ["Pcy", [1055]], ["pcy", [1087]], ["percnt", [37]], ["period", [46]], ["permil", [8240]], ["perp", [8869]], ["pertenk", [8241]], ["Pfr", [120083]], ["pfr", [120109]], ["Phi", [934]], ["phi", [966]], ["phiv", [981]], ["phmmat", [8499]], ["phone", [9742]], ["Pi", [928]], ["pi", [960]], ["pitchfork", [8916]], ["piv", [982]], ["planck", [8463]], ["planckh", [8462]], ["plankv", [8463]], ["plusacir", [10787]], ["plusb", [8862]], ["pluscir", [10786]], ["plus", [43]], ["plusdo", [8724]], ["plusdu", [10789]], ["pluse", [10866]], ["PlusMinus", [177]], ["plusmn", [177]], ["plussim", [10790]], ["plustwo", [10791]], ["pm", [177]], ["Poincareplane", [8460]], ["pointint", [10773]], ["popf", [120161]], ["Popf", [8473]], ["pound", [163]], ["prap", [10935]], ["Pr", [10939]], ["pr", [8826]], ["prcue", [8828]], ["precapprox", [10935]], ["prec", [8826]], ["preccurlyeq", [8828]], ["Precedes", [8826]], ["PrecedesEqual", [10927]], ["PrecedesSlantEqual", [8828]], ["PrecedesTilde", [8830]], ["preceq", [10927]], ["precnapprox", [10937]], ["precneqq", [10933]], ["precnsim", [8936]], ["pre", [10927]], ["prE", [10931]], ["precsim", [8830]], ["prime", [8242]], ["Prime", [8243]], ["primes", [8473]], ["prnap", [10937]], ["prnE", [10933]], ["prnsim", [8936]], ["prod", [8719]], ["Product", [8719]], ["profalar", [9006]], ["profline", [8978]], ["profsurf", [8979]], ["prop", [8733]], ["Proportional", [8733]], ["Proportion", [8759]], ["propto", [8733]], ["prsim", [8830]], ["prurel", [8880]], ["Pscr", [119979]], ["pscr", [120005]], ["Psi", [936]], ["psi", [968]], ["puncsp", [8200]], ["Qfr", [120084]], ["qfr", [120110]], ["qint", [10764]], ["qopf", [120162]], ["Qopf", [8474]], ["qprime", [8279]], ["Qscr", [119980]], ["qscr", [120006]], ["quaternions", [8461]], ["quatint", [10774]], ["quest", [63]], ["questeq", [8799]], ["quot", [34]], ["QUOT", [34]], ["rAarr", [8667]], ["race", [8765, 817]], ["Racute", [340]], ["racute", [341]], ["radic", [8730]], ["raemptyv", [10675]], ["rang", [10217]], ["Rang", [10219]], ["rangd", [10642]], ["range", [10661]], ["rangle", [10217]], ["raquo", [187]], ["rarrap", [10613]], ["rarrb", [8677]], ["rarrbfs", [10528]], ["rarrc", [10547]], ["rarr", [8594]], ["Rarr", [8608]], ["rArr", [8658]], ["rarrfs", [10526]], ["rarrhk", [8618]], ["rarrlp", [8620]], ["rarrpl", [10565]], ["rarrsim", [10612]], ["Rarrtl", [10518]], ["rarrtl", [8611]], ["rarrw", [8605]], ["ratail", [10522]], ["rAtail", [10524]], ["ratio", [8758]], ["rationals", [8474]], ["rbarr", [10509]], ["rBarr", [10511]], ["RBarr", [10512]], ["rbbrk", [10099]], ["rbrace", [125]], ["rbrack", [93]], ["rbrke", [10636]], ["rbrksld", [10638]], ["rbrkslu", [10640]], ["Rcaron", [344]], ["rcaron", [345]], ["Rcedil", [342]], ["rcedil", [343]], ["rceil", [8969]], ["rcub", [125]], ["Rcy", [1056]], ["rcy", [1088]], ["rdca", [10551]], ["rdldhar", [10601]], ["rdquo", [8221]], ["rdquor", [8221]], ["rdsh", [8627]], ["real", [8476]], ["realine", [8475]], ["realpart", [8476]], ["reals", [8477]], ["Re", [8476]], ["rect", [9645]], ["reg", [174]], ["REG", [174]], ["ReverseElement", [8715]], ["ReverseEquilibrium", [8651]], ["ReverseUpEquilibrium", [10607]], ["rfisht", [10621]], ["rfloor", [8971]], ["rfr", [120111]], ["Rfr", [8476]], ["rHar", [10596]], ["rhard", [8641]], ["rharu", [8640]], ["rharul", [10604]], ["Rho", [929]], ["rho", [961]], ["rhov", [1009]], ["RightAngleBracket", [10217]], ["RightArrowBar", [8677]], ["rightarrow", [8594]], ["RightArrow", [8594]], ["Rightarrow", [8658]], ["RightArrowLeftArrow", [8644]], ["rightarrowtail", [8611]], ["RightCeiling", [8969]], ["RightDoubleBracket", [10215]], ["RightDownTeeVector", [10589]], ["RightDownVectorBar", [10581]], ["RightDownVector", [8642]], ["RightFloor", [8971]], ["rightharpoondown", [8641]], ["rightharpoonup", [8640]], ["rightleftarrows", [8644]], ["rightleftharpoons", [8652]], ["rightrightarrows", [8649]], ["rightsquigarrow", [8605]], ["RightTeeArrow", [8614]], ["RightTee", [8866]], ["RightTeeVector", [10587]], ["rightthreetimes", [8908]], ["RightTriangleBar", [10704]], ["RightTriangle", [8883]], ["RightTriangleEqual", [8885]], ["RightUpDownVector", [10575]], ["RightUpTeeVector", [10588]], ["RightUpVectorBar", [10580]], ["RightUpVector", [8638]], ["RightVectorBar", [10579]], ["RightVector", [8640]], ["ring", [730]], ["risingdotseq", [8787]], ["rlarr", [8644]], ["rlhar", [8652]], ["rlm", [8207]], ["rmoustache", [9137]], ["rmoust", [9137]], ["rnmid", [10990]], ["roang", [10221]], ["roarr", [8702]], ["robrk", [10215]], ["ropar", [10630]], ["ropf", [120163]], ["Ropf", [8477]], ["roplus", [10798]], ["rotimes", [10805]], ["RoundImplies", [10608]], ["rpar", [41]], ["rpargt", [10644]], ["rppolint", [10770]], ["rrarr", [8649]], ["Rrightarrow", [8667]], ["rsaquo", [8250]], ["rscr", [120007]], ["Rscr", [8475]], ["rsh", [8625]], ["Rsh", [8625]], ["rsqb", [93]], ["rsquo", [8217]], ["rsquor", [8217]], ["rthree", [8908]], ["rtimes", [8906]], ["rtri", [9657]], ["rtrie", [8885]], ["rtrif", [9656]], ["rtriltri", [10702]], ["RuleDelayed", [10740]], ["ruluhar", [10600]], ["rx", [8478]], ["Sacute", [346]], ["sacute", [347]], ["sbquo", [8218]], ["scap", [10936]], ["Scaron", [352]], ["scaron", [353]], ["Sc", [10940]], ["sc", [8827]], ["sccue", [8829]], ["sce", [10928]], ["scE", [10932]], ["Scedil", [350]], ["scedil", [351]], ["Scirc", [348]], ["scirc", [349]], ["scnap", [10938]], ["scnE", [10934]], ["scnsim", [8937]], ["scpolint", [10771]], ["scsim", [8831]], ["Scy", [1057]], ["scy", [1089]], ["sdotb", [8865]], ["sdot", [8901]], ["sdote", [10854]], ["searhk", [10533]], ["searr", [8600]], ["seArr", [8664]], ["searrow", [8600]], ["sect", [167]], ["semi", [59]], ["seswar", [10537]], ["setminus", [8726]], ["setmn", [8726]], ["sext", [10038]], ["Sfr", [120086]], ["sfr", [120112]], ["sfrown", [8994]], ["sharp", [9839]], ["SHCHcy", [1065]], ["shchcy", [1097]], ["SHcy", [1064]], ["shcy", [1096]], ["ShortDownArrow", [8595]], ["ShortLeftArrow", [8592]], ["shortmid", [8739]], ["shortparallel", [8741]], ["ShortRightArrow", [8594]], ["ShortUpArrow", [8593]], ["shy", [173]], ["Sigma", [931]], ["sigma", [963]], ["sigmaf", [962]], ["sigmav", [962]], ["sim", [8764]], ["simdot", [10858]], ["sime", [8771]], ["simeq", [8771]], ["simg", [10910]], ["simgE", [10912]], ["siml", [10909]], ["simlE", [10911]], ["simne", [8774]], ["simplus", [10788]], ["simrarr", [10610]], ["slarr", [8592]], ["SmallCircle", [8728]], ["smallsetminus", [8726]], ["smashp", [10803]], ["smeparsl", [10724]], ["smid", [8739]], ["smile", [8995]], ["smt", [10922]], ["smte", [10924]], ["smtes", [10924, 65024]], ["SOFTcy", [1068]], ["softcy", [1100]], ["solbar", [9023]], ["solb", [10692]], ["sol", [47]], ["Sopf", [120138]], ["sopf", [120164]], ["spades", [9824]], ["spadesuit", [9824]], ["spar", [8741]], ["sqcap", [8851]], ["sqcaps", [8851, 65024]], ["sqcup", [8852]], ["sqcups", [8852, 65024]], ["Sqrt", [8730]], ["sqsub", [8847]], ["sqsube", [8849]], ["sqsubset", [8847]], ["sqsubseteq", [8849]], ["sqsup", [8848]], ["sqsupe", [8850]], ["sqsupset", [8848]], ["sqsupseteq", [8850]], ["square", [9633]], ["Square", [9633]], ["SquareIntersection", [8851]], ["SquareSubset", [8847]], ["SquareSubsetEqual", [8849]], ["SquareSuperset", [8848]], ["SquareSupersetEqual", [8850]], ["SquareUnion", [8852]], ["squarf", [9642]], ["squ", [9633]], ["squf", [9642]], ["srarr", [8594]], ["Sscr", [119982]], ["sscr", [120008]], ["ssetmn", [8726]], ["ssmile", [8995]], ["sstarf", [8902]], ["Star", [8902]], ["star", [9734]], ["starf", [9733]], ["straightepsilon", [1013]], ["straightphi", [981]], ["strns", [175]], ["sub", [8834]], ["Sub", [8912]], ["subdot", [10941]], ["subE", [10949]], ["sube", [8838]], ["subedot", [10947]], ["submult", [10945]], ["subnE", [10955]], ["subne", [8842]], ["subplus", [10943]], ["subrarr", [10617]], ["subset", [8834]], ["Subset", [8912]], ["subseteq", [8838]], ["subseteqq", [10949]], ["SubsetEqual", [8838]], ["subsetneq", [8842]], ["subsetneqq", [10955]], ["subsim", [10951]], ["subsub", [10965]], ["subsup", [10963]], ["succapprox", [10936]], ["succ", [8827]], ["succcurlyeq", [8829]], ["Succeeds", [8827]], ["SucceedsEqual", [10928]], ["SucceedsSlantEqual", [8829]], ["SucceedsTilde", [8831]], ["succeq", [10928]], ["succnapprox", [10938]], ["succneqq", [10934]], ["succnsim", [8937]], ["succsim", [8831]], ["SuchThat", [8715]], ["sum", [8721]], ["Sum", [8721]], ["sung", [9834]], ["sup1", [185]], ["sup2", [178]], ["sup3", [179]], ["sup", [8835]], ["Sup", [8913]], ["supdot", [10942]], ["supdsub", [10968]], ["supE", [10950]], ["supe", [8839]], ["supedot", [10948]], ["Superset", [8835]], ["SupersetEqual", [8839]], ["suphsol", [10185]], ["suphsub", [10967]], ["suplarr", [10619]], ["supmult", [10946]], ["supnE", [10956]], ["supne", [8843]], ["supplus", [10944]], ["supset", [8835]], ["Supset", [8913]], ["supseteq", [8839]], ["supseteqq", [10950]], ["supsetneq", [8843]], ["supsetneqq", [10956]], ["supsim", [10952]], ["supsub", [10964]], ["supsup", [10966]], ["swarhk", [10534]], ["swarr", [8601]], ["swArr", [8665]], ["swarrow", [8601]], ["swnwar", [10538]], ["szlig", [223]], ["Tab", [9]], ["target", [8982]], ["Tau", [932]], ["tau", [964]], ["tbrk", [9140]], ["Tcaron", [356]], ["tcaron", [357]], ["Tcedil", [354]], ["tcedil", [355]], ["Tcy", [1058]], ["tcy", [1090]], ["tdot", [8411]], ["telrec", [8981]], ["Tfr", [120087]], ["tfr", [120113]], ["there4", [8756]], ["therefore", [8756]], ["Therefore", [8756]], ["Theta", [920]], ["theta", [952]], ["thetasym", [977]], ["thetav", [977]], ["thickapprox", [8776]], ["thicksim", [8764]], ["ThickSpace", [8287, 8202]], ["ThinSpace", [8201]], ["thinsp", [8201]], ["thkap", [8776]], ["thksim", [8764]], ["THORN", [222]], ["thorn", [254]], ["tilde", [732]], ["Tilde", [8764]], ["TildeEqual", [8771]], ["TildeFullEqual", [8773]], ["TildeTilde", [8776]], ["timesbar", [10801]], ["timesb", [8864]], ["times", [215]], ["timesd", [10800]], ["tint", [8749]], ["toea", [10536]], ["topbot", [9014]], ["topcir", [10993]], ["top", [8868]], ["Topf", [120139]], ["topf", [120165]], ["topfork", [10970]], ["tosa", [10537]], ["tprime", [8244]], ["trade", [8482]], ["TRADE", [8482]], ["triangle", [9653]], ["triangledown", [9663]], ["triangleleft", [9667]], ["trianglelefteq", [8884]], ["triangleq", [8796]], ["triangleright", [9657]], ["trianglerighteq", [8885]], ["tridot", [9708]], ["trie", [8796]], ["triminus", [10810]], ["TripleDot", [8411]], ["triplus", [10809]], ["trisb", [10701]], ["tritime", [10811]], ["trpezium", [9186]], ["Tscr", [119983]], ["tscr", [120009]], ["TScy", [1062]], ["tscy", [1094]], ["TSHcy", [1035]], ["tshcy", [1115]], ["Tstrok", [358]], ["tstrok", [359]], ["twixt", [8812]], ["twoheadleftarrow", [8606]], ["twoheadrightarrow", [8608]], ["Uacute", [218]], ["uacute", [250]], ["uarr", [8593]], ["Uarr", [8607]], ["uArr", [8657]], ["Uarrocir", [10569]], ["Ubrcy", [1038]], ["ubrcy", [1118]], ["Ubreve", [364]], ["ubreve", [365]], ["Ucirc", [219]], ["ucirc", [251]], ["Ucy", [1059]], ["ucy", [1091]], ["udarr", [8645]], ["Udblac", [368]], ["udblac", [369]], ["udhar", [10606]], ["ufisht", [10622]], ["Ufr", [120088]], ["ufr", [120114]], ["Ugrave", [217]], ["ugrave", [249]], ["uHar", [10595]], ["uharl", [8639]], ["uharr", [8638]], ["uhblk", [9600]], ["ulcorn", [8988]], ["ulcorner", [8988]], ["ulcrop", [8975]], ["ultri", [9720]], ["Umacr", [362]], ["umacr", [363]], ["uml", [168]], ["UnderBar", [95]], ["UnderBrace", [9183]], ["UnderBracket", [9141]], ["UnderParenthesis", [9181]], ["Union", [8899]], ["UnionPlus", [8846]], ["Uogon", [370]], ["uogon", [371]], ["Uopf", [120140]], ["uopf", [120166]], ["UpArrowBar", [10514]], ["uparrow", [8593]], ["UpArrow", [8593]], ["Uparrow", [8657]], ["UpArrowDownArrow", [8645]], ["updownarrow", [8597]], ["UpDownArrow", [8597]], ["Updownarrow", [8661]], ["UpEquilibrium", [10606]], ["upharpoonleft", [8639]], ["upharpoonright", [8638]], ["uplus", [8846]], ["UpperLeftArrow", [8598]], ["UpperRightArrow", [8599]], ["upsi", [965]], ["Upsi", [978]], ["upsih", [978]], ["Upsilon", [933]], ["upsilon", [965]], ["UpTeeArrow", [8613]], ["UpTee", [8869]], ["upuparrows", [8648]], ["urcorn", [8989]], ["urcorner", [8989]], ["urcrop", [8974]], ["Uring", [366]], ["uring", [367]], ["urtri", [9721]], ["Uscr", [119984]], ["uscr", [120010]], ["utdot", [8944]], ["Utilde", [360]], ["utilde", [361]], ["utri", [9653]], ["utrif", [9652]], ["uuarr", [8648]], ["Uuml", [220]], ["uuml", [252]], ["uwangle", [10663]], ["vangrt", [10652]], ["varepsilon", [1013]], ["varkappa", [1008]], ["varnothing", [8709]], ["varphi", [981]], ["varpi", [982]], ["varpropto", [8733]], ["varr", [8597]], ["vArr", [8661]], ["varrho", [1009]], ["varsigma", [962]], ["varsubsetneq", [8842, 65024]], ["varsubsetneqq", [10955, 65024]], ["varsupsetneq", [8843, 65024]], ["varsupsetneqq", [10956, 65024]], ["vartheta", [977]], ["vartriangleleft", [8882]], ["vartriangleright", [8883]], ["vBar", [10984]], ["Vbar", [10987]], ["vBarv", [10985]], ["Vcy", [1042]], ["vcy", [1074]], ["vdash", [8866]], ["vDash", [8872]], ["Vdash", [8873]], ["VDash", [8875]], ["Vdashl", [10982]], ["veebar", [8891]], ["vee", [8744]], ["Vee", [8897]], ["veeeq", [8794]], ["vellip", [8942]], ["verbar", [124]], ["Verbar", [8214]], ["vert", [124]], ["Vert", [8214]], ["VerticalBar", [8739]], ["VerticalLine", [124]], ["VerticalSeparator", [10072]], ["VerticalTilde", [8768]], ["VeryThinSpace", [8202]], ["Vfr", [120089]], ["vfr", [120115]], ["vltri", [8882]], ["vnsub", [8834, 8402]], ["vnsup", [8835, 8402]], ["Vopf", [120141]], ["vopf", [120167]], ["vprop", [8733]], ["vrtri", [8883]], ["Vscr", [119985]], ["vscr", [120011]], ["vsubnE", [10955, 65024]], ["vsubne", [8842, 65024]], ["vsupnE", [10956, 65024]], ["vsupne", [8843, 65024]], ["Vvdash", [8874]], ["vzigzag", [10650]], ["Wcirc", [372]], ["wcirc", [373]], ["wedbar", [10847]], ["wedge", [8743]], ["Wedge", [8896]], ["wedgeq", [8793]], ["weierp", [8472]], ["Wfr", [120090]], ["wfr", [120116]], ["Wopf", [120142]], ["wopf", [120168]], ["wp", [8472]], ["wr", [8768]], ["wreath", [8768]], ["Wscr", [119986]], ["wscr", [120012]], ["xcap", [8898]], ["xcirc", [9711]], ["xcup", [8899]], ["xdtri", [9661]], ["Xfr", [120091]], ["xfr", [120117]], ["xharr", [10231]], ["xhArr", [10234]], ["Xi", [926]], ["xi", [958]], ["xlarr", [10229]], ["xlArr", [10232]], ["xmap", [10236]], ["xnis", [8955]], ["xodot", [10752]], ["Xopf", [120143]], ["xopf", [120169]], ["xoplus", [10753]], ["xotime", [10754]], ["xrarr", [10230]], ["xrArr", [10233]], ["Xscr", [119987]], ["xscr", [120013]], ["xsqcup", [10758]], ["xuplus", [10756]], ["xutri", [9651]], ["xvee", [8897]], ["xwedge", [8896]], ["Yacute", [221]], ["yacute", [253]], ["YAcy", [1071]], ["yacy", [1103]], ["Ycirc", [374]], ["ycirc", [375]], ["Ycy", [1067]], ["ycy", [1099]], ["yen", [165]], ["Yfr", [120092]], ["yfr", [120118]], ["YIcy", [1031]], ["yicy", [1111]], ["Yopf", [120144]], ["yopf", [120170]], ["Yscr", [119988]], ["yscr", [120014]], ["YUcy", [1070]], ["yucy", [1102]], ["yuml", [255]], ["Yuml", [376]], ["Zacute", [377]], ["zacute", [378]], ["Zcaron", [381]], ["zcaron", [382]], ["Zcy", [1047]], ["zcy", [1079]], ["Zdot", [379]], ["zdot", [380]], ["zeetrf", [8488]], ["ZeroWidthSpace", [8203]], ["Zeta", [918]], ["zeta", [950]], ["zfr", [120119]], ["Zfr", [8488]], ["ZHcy", [1046]], ["zhcy", [1078]], ["zigrarr", [8669]], ["zopf", [120171]], ["Zopf", [8484]], ["Zscr", [119989]], ["zscr", [120015]], ["zwj", [8205]], ["zwnj", [8204]]];
    var alphaIndex = {};
    var charIndex = {};
    createIndexes(alphaIndex, charIndex);
    function Html5Entities() {
    }
    Html5Entities.prototype.decode = function(str) {
      if (str.length === 0) {
        return "";
      }
      return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
          var code = entity.charAt(1) === "x" ? parseInt(entity.substr(2).toLowerCase(), 16) : parseInt(entity.substr(1));
          if (!(isNaN(code) || code < -32768 || code > 65535)) {
            chr = String.fromCharCode(code);
          }
        } else {
          chr = alphaIndex[entity];
        }
        return chr || s;
      });
    };
    Html5Entities.decode = function(str) {
      return new Html5Entities().decode(str);
    };
    Html5Entities.prototype.encode = function(str) {
      var strLength = str.length;
      if (strLength === 0) {
        return "";
      }
      var result = "";
      var i = 0;
      while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
          var alpha = charInfo[str.charCodeAt(i + 1)];
          if (alpha) {
            i++;
          } else {
            alpha = charInfo[""];
          }
          if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
          }
        }
        result += str.charAt(i);
        i++;
      }
      return result;
    };
    Html5Entities.encode = function(str) {
      return new Html5Entities().encode(str);
    };
    Html5Entities.prototype.encodeNonUTF = function(str) {
      var strLength = str.length;
      if (strLength === 0) {
        return "";
      }
      var result = "";
      var i = 0;
      while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
          var alpha = charInfo[str.charCodeAt(i + 1)];
          if (alpha) {
            i++;
          } else {
            alpha = charInfo[""];
          }
          if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
          }
        }
        if (c < 32 || c > 126) {
          result += "&#" + c + ";";
        } else {
          result += str.charAt(i);
        }
        i++;
      }
      return result;
    };
    Html5Entities.encodeNonUTF = function(str) {
      return new Html5Entities().encodeNonUTF(str);
    };
    Html5Entities.prototype.encodeNonASCII = function(str) {
      var strLength = str.length;
      if (strLength === 0) {
        return "";
      }
      var result = "";
      var i = 0;
      while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
          result += str[i++];
          continue;
        }
        result += "&#" + c + ";";
        i++;
      }
      return result;
    };
    Html5Entities.encodeNonASCII = function(str) {
      return new Html5Entities().encodeNonASCII(str);
    };
    function createIndexes(alphaIndex2, charIndex2) {
      var i = ENTITIES.length;
      var _results = [];
      while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = chr < 32 || chr > 126 || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
          charInfo = charIndex2[chr] = charIndex2[chr] || {};
        }
        if (chars[1]) {
          var chr2 = chars[1];
          alphaIndex2[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
          _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
          alphaIndex2[alpha] = String.fromCharCode(chr);
          _results.push(addChar && (charInfo[""] = alpha));
        }
      }
    }
    module.exports = Html5Entities;
  }
});

// ../Server/node_modules/html-entities/index.js
var require_html_entities = __commonJS({
  "../Server/node_modules/html-entities/index.js"(exports, module) {
    module.exports = {
      XmlEntities: require_xml_entities(),
      Html4Entities: require_html4_entities(),
      Html5Entities: require_html5_entities(),
      AllHtmlEntities: require_html5_entities()
    };
  }
});

// ../Server/node_modules/textract/lib/util.js
var require_util2 = __commonJS({
  "../Server/node_modules/textract/lib/util.js"(exports, module) {
    var exec = require_child_process().exec;
    var path = require_path();
    var fs = require_fs();
    var os = require_os();
    var outDir = path.join(os.tmpdir(), "textract");
    var replacements = [
      [/[\u201C|\u201D|]||/g, '"'],
      // fancy double quotes
      [/[\u2018|\u2019]||]/g, "'"],
      // fancy single quotes/apostrophes
      [//g, ""],
      // elipses
      [/|/g, ""]
      // long hyphen
    ];
    var rLen = replacements.length;
    if (!fs.existsSync(outDir)) {
      fs.mkdirSync(outDir);
    }
    function replaceBadCharacters(text) {
      var i, repl;
      for (i = 0; i < rLen; i++) {
        repl = replacements[i];
        text = text.replace(repl[0], repl[1]);
      }
      return text;
    }
    function yauzlError(err, cb) {
      var msg = err.message;
      if (msg === "end of central directory record signature not found") {
        msg = "File not correctly recognized as zip file, " + msg;
      }
      cb(new Error(msg), null);
    }
    function createExecOptions(type, options) {
      var execOptions = {};
      if (options[type] && options[type].exec) {
        execOptions = options[type].exec;
      } else {
        if (options.exec) {
          execOptions = options.exec;
        }
      }
      return execOptions;
    }
    function unzipCheck(type, cb) {
      exec(
        "unzip",
        function(error) {
          if (error) {
            console.error("textract: 'unzip' does not appear to be installed, so textract will be unable to extract " + type + ".");
          }
          cb(error === null);
        }
      );
    }
    function getTextFromZipFile(zipfile, entry, cb) {
      zipfile.openReadStream(entry, function(err, readStream) {
        var text = "", error = "";
        if (err) {
          cb(err, null);
          return;
        }
        readStream.on("data", function(chunk) {
          text += chunk;
        });
        readStream.on("end", function() {
          if (error.length > 0) {
            cb(error, null);
          } else {
            cb(null, text);
          }
        });
        readStream.on("error", function(_err) {
          error += _err;
        });
      });
    }
    function runExecIntoFile(label, filePath, options, execOptions, genCommand, cb) {
      var fileTempOutPath = path.join(outDir, path.basename(filePath, path.extname(filePath))), escapedFilePath = filePath.replace(/\s/g, "\\ "), escapedFileTempOutPath = fileTempOutPath.replace(/\s/g, "\\ "), cmd = genCommand(options, escapedFilePath, escapedFileTempOutPath);
      exec(
        cmd,
        execOptions,
        function(error) {
          if (error !== null) {
            error = new Error("Error extracting [[ " + path.basename(filePath) + " ]], exec error: " + error.message);
            cb(error, null);
            return;
          }
          fs.exists(fileTempOutPath + ".txt", function(exists) {
            if (exists) {
              fs.readFile(fileTempOutPath + ".txt", "utf8", function(error2, text) {
                if (error2) {
                  error2 = new Error("Error reading" + label + " output at [[ " + fileTempOutPath + " ]], error: " + error2.message);
                  cb(error2, null);
                } else {
                  fs.unlink(fileTempOutPath + ".txt", function(error3) {
                    if (error3) {
                      error3 = new Error("Error, " + label + " , cleaning up temp file [[ " + fileTempOutPath + " ]], error: " + error3.message);
                      cb(error3, null);
                    } else {
                      cb(null, text.toString());
                    }
                  });
                }
              });
            } else {
              error = new Error("Error reading " + label + " output at [[ " + fileTempOutPath + " ]], file does not exist");
              cb(error, null);
            }
          });
        }
      );
    }
    module.exports = {
      createExecOptions,
      unzipCheck,
      getTextFromZipFile,
      yauzlError,
      runExecIntoFile,
      replaceBadCharacters
    };
  }
});

// ../Server/node_modules/textract/lib/extract.js
var require_extract = __commonJS({
  "../Server/node_modules/textract/lib/extract.js"(exports, module) {
    var fs = require_fs();
    var path = require_path();
    var XmlEntities = require_html_entities().XmlEntities;
    var util = require_util2();
    var extractorPath = path.join(__dirname, "extractors");
    var entities = new XmlEntities();
    var typeExtractors = {};
    var regexExtractors = [];
    var failedExtractorTypes = {};
    var totalExtractors = 0;
    var satisfiedExtractors = 0;
    var hasInitialized = false;
    var STRIP_ONLY_SINGLE_LINEBREAKS = /(^|[^\n])\n(?!\n)/g;
    var WHITELIST_PRESERVE_LINEBREAKS = /[^A-Za-z\x80-\xFF\x24\u20AC\xA3\xA5 0-9 \u2015\u2116\u2018\u2019\u201C|\u201D\u2026 \uFF0C \u2013 \u2014 \u00C0-\u1FFF \u2C00-\uD7FF \uFB50\uFDFF \uFE70\uFEFF \uFF01-\uFFE6 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~'-\w\n\r]*/g;
    var WHITELIST_STRIP_LINEBREAKS = /[^A-Za-z\x80-\xFF\x24\u20AC\xA3\xA5 0-9 \u2015\u2116\u2018\u2019\u201C|\u201D\u2026 \uFF0C \u2013 \u2014 \u00C0-\u1FFF \u2C00-\uD7FF \uFB50\uFDFF \uFE70\uFEFF \uFF01-\uFFE6 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~'-\w]*/g;
    function registerExtractor(extractor) {
      if (extractor.types) {
        extractor.types.forEach(function(type) {
          if (typeof type === "string") {
            type = type.toLowerCase();
            typeExtractors[type] = extractor.extract;
          } else {
            if (type instanceof RegExp) {
              regexExtractors.push({ reg: type, extractor: extractor.extract });
            }
          }
        });
      }
    }
    function registerFailedExtractor(extractor, failedMessage) {
      if (extractor.types) {
        extractor.types.forEach(function(type) {
          failedExtractorTypes[type.toLowerCase()] = failedMessage;
        });
      }
    }
    function testExtractor(extractor, options) {
      extractor.test(options, function(passedTest, failedMessage) {
        satisfiedExtractors++;
        if (passedTest) {
          registerExtractor(extractor);
        } else {
          registerFailedExtractor(extractor, failedMessage);
        }
      });
    }
    function cleanseText(options, cb) {
      return function(error, text) {
        if (!error) {
          text = util.replaceBadCharacters(text);
          if (options.preserveLineBreaks || options.preserveOnlyMultipleLineBreaks) {
            if (options.preserveOnlyMultipleLineBreaks) {
              text = text.replace(STRIP_ONLY_SINGLE_LINEBREAKS, "$1 ").trim();
            }
            text = text.replace(WHITELIST_PRESERVE_LINEBREAKS, " ");
          } else {
            text = text.replace(WHITELIST_STRIP_LINEBREAKS, " ");
          }
          text = text.replace(/ (?! )/g, "").replace(/[ \t\v\u00A0]{2,}/g, " ");
          text = entities.decode(text);
        }
        cb(error, text);
      };
    }
    function initializeExtractors(options) {
      var extractors;
      hasInitialized = true;
      extractors = fs.readdirSync(extractorPath).map(function(item) {
        var fullExtractorPath = path.join(extractorPath, item);
        return __require(fullExtractorPath);
      });
      extractors.forEach(function(extractor) {
        if (extractor.test) {
          testExtractor(extractor, options);
        } else {
          satisfiedExtractors++;
          registerExtractor(extractor);
        }
      });
      totalExtractors = extractors.length;
    }
    function findExtractor(type) {
      var i, iLen = regexExtractors.length, extractor, regexExtractor;
      type = type.toLowerCase();
      if (typeExtractors[type]) {
        extractor = typeExtractors[type];
      } else {
        for (i = 0; i < iLen; i++) {
          regexExtractor = regexExtractors[i];
          if (type.match(regexExtractor.reg)) {
            extractor = regexExtractor.extractor;
          }
        }
      }
      return extractor;
    }
    function extract(type, filePath, options, cb) {
      var error, msg, theExtractor;
      if (!hasInitialized) {
        initializeExtractors(options);
      }
      if (totalExtractors === satisfiedExtractors) {
        theExtractor = findExtractor(type);
        if (theExtractor) {
          cb = cleanseText(options, cb);
          theExtractor(filePath, options, cb);
        } else {
          msg = "Error for type: [[ " + type + " ]], file: [[ " + filePath + " ]]";
          if (failedExtractorTypes[type]) {
            msg += ", extractor for type exists, but failed to initialize. Message: " + failedExtractorTypes[type];
          }
          error = new Error(msg);
          error.typeNotFound = true;
          cb(error, null);
        }
      } else {
        setTimeout(function() {
          extract(type, filePath, options, cb);
        }, 100);
      }
    }
    module.exports = extract;
  }
});

// ../Server/node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "../Server/node_modules/process-nextick-args/index.js"(exports, module) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module.exports = { nextTick };
    } else {
      module.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// ../Server/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../Server/node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../Server/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "../Server/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// ../Server/node_modules/core-util-is/lib/util.js
var require_util3 = __commonJS({
  "../Server/node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_buffer().Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../Server/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "../Server/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require_util();
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module.exports = (function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    })();
    if (util && util.inspect && util.inspect.custom) {
      module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../Server/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../Server/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy
    };
  }
});

// ../Server/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../Server/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ended) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../Server/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../Server/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module.exports = Duplex;
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../Server/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../Server/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    var debugUtil = require_util();
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) pna.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ (function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          })(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// ../Server/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../Server/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../Server/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../Server/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util3());
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../Server/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "../Server/node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
  }
});

// ../Server/node_modules/duplexer2/index.js
var require_duplexer2 = __commonJS({
  "../Server/node_modules/duplexer2/index.js"(exports, module) {
    "use strict";
    var stream = require_readable_browser();
    function DuplexWrapper(options, writable, readable) {
      if (typeof readable === "undefined") {
        readable = writable;
        writable = options;
        options = null;
      }
      stream.Duplex.call(this, options);
      if (typeof readable.read !== "function") {
        readable = new stream.Readable(options).wrap(readable);
      }
      this._writable = writable;
      this._readable = readable;
      this._waiting = false;
      var self2 = this;
      writable.once("finish", function() {
        self2.end();
      });
      this.once("finish", function() {
        writable.end();
      });
      readable.on("readable", function() {
        if (self2._waiting) {
          self2._waiting = false;
          self2._read();
        }
      });
      readable.once("end", function() {
        self2.push(null);
      });
      if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
        writable.on("error", function(err) {
          self2.emit("error", err);
        });
        readable.on("error", function(err) {
          self2.emit("error", err);
        });
      }
    }
    DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, { constructor: { value: DuplexWrapper } });
    DuplexWrapper.prototype._write = function _write(input, encoding, done) {
      this._writable.write(input, encoding, done);
    };
    DuplexWrapper.prototype._read = function _read() {
      var buf;
      var reads = 0;
      while ((buf = this._readable.read()) !== null) {
        this.push(buf);
        reads++;
      }
      if (reads === 0) {
        this._waiting = true;
      }
    };
    module.exports = function duplex2(options, writable, readable) {
      return new DuplexWrapper(options, writable, readable);
    };
    module.exports.DuplexWrapper = DuplexWrapper;
  }
});

// ../Server/node_modules/got/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../Server/node_modules/got/node_modules/is-stream/index.js"(exports, module) {
    "use strict";
    var isStream = module.exports = function(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    };
    isStream.writable = function(stream) {
      return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    };
    isStream.readable = function(stream) {
      return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    };
    isStream.duplex = function(stream) {
      return isStream.writable(stream) && isStream.readable(stream);
    };
    isStream.transform = function(stream) {
      return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    };
  }
});

// ../Server/node_modules/pinkie/index.js
var require_pinkie = __commonJS({
  "../Server/node_modules/pinkie/index.js"(exports, module) {
    "use strict";
    var PENDING = "pending";
    var SETTLED = "settled";
    var FULFILLED = "fulfilled";
    var REJECTED = "rejected";
    var NOOP = function() {
    };
    var isNode = typeof global !== "undefined" && typeof global.process !== "undefined" && typeof global.process.emit === "function";
    var asyncSetTimer = typeof setImmediate === "undefined" ? setTimeout : setImmediate;
    var asyncQueue = [];
    var asyncTimer;
    function asyncFlush() {
      for (var i = 0; i < asyncQueue.length; i++) {
        asyncQueue[i][0](asyncQueue[i][1]);
      }
      asyncQueue = [];
      asyncTimer = false;
    }
    function asyncCall(callback, arg) {
      asyncQueue.push([callback, arg]);
      if (!asyncTimer) {
        asyncTimer = true;
        asyncSetTimer(asyncFlush, 0);
      }
    }
    function invokeResolver(resolver, promise) {
      function resolvePromise(value) {
        resolve(promise, value);
      }
      function rejectPromise(reason) {
        reject(promise, reason);
      }
      try {
        resolver(resolvePromise, rejectPromise);
      } catch (e) {
        rejectPromise(e);
      }
    }
    function invokeCallback(subscriber) {
      var owner = subscriber.owner;
      var settled = owner._state;
      var value = owner._data;
      var callback = subscriber[settled];
      var promise = subscriber.then;
      if (typeof callback === "function") {
        settled = FULFILLED;
        try {
          value = callback(value);
        } catch (e) {
          reject(promise, e);
        }
      }
      if (!handleThenable(promise, value)) {
        if (settled === FULFILLED) {
          resolve(promise, value);
        }
        if (settled === REJECTED) {
          reject(promise, value);
        }
      }
    }
    function handleThenable(promise, value) {
      var resolved;
      try {
        if (promise === value) {
          throw new TypeError("A promises callback cannot return that same promise.");
        }
        if (value && (typeof value === "function" || typeof value === "object")) {
          var then = value.then;
          if (typeof then === "function") {
            then.call(value, function(val) {
              if (!resolved) {
                resolved = true;
                if (value === val) {
                  fulfill(promise, val);
                } else {
                  resolve(promise, val);
                }
              }
            }, function(reason) {
              if (!resolved) {
                resolved = true;
                reject(promise, reason);
              }
            });
            return true;
          }
        }
      } catch (e) {
        if (!resolved) {
          reject(promise, e);
        }
        return true;
      }
      return false;
    }
    function resolve(promise, value) {
      if (promise === value || !handleThenable(promise, value)) {
        fulfill(promise, value);
      }
    }
    function fulfill(promise, value) {
      if (promise._state === PENDING) {
        promise._state = SETTLED;
        promise._data = value;
        asyncCall(publishFulfillment, promise);
      }
    }
    function reject(promise, reason) {
      if (promise._state === PENDING) {
        promise._state = SETTLED;
        promise._data = reason;
        asyncCall(publishRejection, promise);
      }
    }
    function publish(promise) {
      promise._then = promise._then.forEach(invokeCallback);
    }
    function publishFulfillment(promise) {
      promise._state = FULFILLED;
      publish(promise);
    }
    function publishRejection(promise) {
      promise._state = REJECTED;
      publish(promise);
      if (!promise._handled && isNode) {
        global.process.emit("unhandledRejection", promise._data, promise);
      }
    }
    function notifyRejectionHandled(promise) {
      global.process.emit("rejectionHandled", promise);
    }
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("Promise resolver " + resolver + " is not a function");
      }
      if (this instanceof Promise2 === false) {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      this._then = [];
      invokeResolver(resolver, this);
    }
    Promise2.prototype = {
      constructor: Promise2,
      _state: PENDING,
      _then: null,
      _data: void 0,
      _handled: false,
      then: function(onFulfillment, onRejection) {
        var subscriber = {
          owner: this,
          then: new this.constructor(NOOP),
          fulfilled: onFulfillment,
          rejected: onRejection
        };
        if ((onRejection || onFulfillment) && !this._handled) {
          this._handled = true;
          if (this._state === REJECTED && isNode) {
            asyncCall(notifyRejectionHandled, this);
          }
        }
        if (this._state === FULFILLED || this._state === REJECTED) {
          asyncCall(invokeCallback, subscriber);
        } else {
          this._then.push(subscriber);
        }
        return subscriber.then;
      },
      catch: function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    Promise2.all = function(promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("You must pass an array to Promise.all().");
      }
      return new Promise2(function(resolve2, reject2) {
        var results = [];
        var remaining = 0;
        function resolver(index) {
          remaining++;
          return function(value) {
            results[index] = value;
            if (!--remaining) {
              resolve2(results);
            }
          };
        }
        for (var i = 0, promise; i < promises.length; i++) {
          promise = promises[i];
          if (promise && typeof promise.then === "function") {
            promise.then(resolver(i), reject2);
          } else {
            results[i] = promise;
          }
        }
        if (!remaining) {
          resolve2(results);
        }
      });
    };
    Promise2.race = function(promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("You must pass an array to Promise.race().");
      }
      return new Promise2(function(resolve2, reject2) {
        for (var i = 0, promise; i < promises.length; i++) {
          promise = promises[i];
          if (promise && typeof promise.then === "function") {
            promise.then(resolve2, reject2);
          } else {
            resolve2(promise);
          }
        }
      });
    };
    Promise2.resolve = function(value) {
      if (value && typeof value === "object" && value.constructor === Promise2) {
        return value;
      }
      return new Promise2(function(resolve2) {
        resolve2(value);
      });
    };
    Promise2.reject = function(reason) {
      return new Promise2(function(resolve2, reject2) {
        reject2(reason);
      });
    };
    module.exports = Promise2;
  }
});

// ../Server/node_modules/pinkie-promise/index.js
var require_pinkie_promise = __commonJS({
  "../Server/node_modules/pinkie-promise/index.js"(exports, module) {
    "use strict";
    module.exports = typeof Promise === "function" ? Promise : require_pinkie();
  }
});

// ../Server/node_modules/read-all-stream/index.js
var require_read_all_stream = __commonJS({
  "../Server/node_modules/read-all-stream/index.js"(exports, module) {
    "use strict";
    var Writable = require_readable_browser().Writable;
    var inherits = require_util().inherits;
    var Promise2 = require_pinkie_promise();
    function BufferStream() {
      Writable.call(this, { objectMode: true });
      this.buffer = [];
      this.length = 0;
    }
    inherits(BufferStream, Writable);
    BufferStream.prototype._write = function(chunk, enc, next) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = new Buffer(chunk);
      }
      this.buffer.push(chunk);
      this.length += chunk.length;
      next();
    };
    module.exports = function read(stream, options, cb) {
      if (!stream) {
        throw new Error("stream argument is required");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof options === "string" || options === void 0 || options === null) {
        options = { encoding: options };
      }
      if (options.encoding === void 0) {
        options.encoding = "utf8";
      }
      var promise;
      if (!cb) {
        var resolve, reject;
        promise = new Promise2(function(_res, _rej) {
          resolve = _res;
          reject = _rej;
        });
        cb = function(err, data) {
          if (err) {
            return reject(err);
          }
          resolve(data);
        };
      }
      var sink = new BufferStream();
      sink.on("finish", function() {
        var data = Buffer.concat(this.buffer, this.length);
        if (options.encoding) {
          data = data.toString(options.encoding);
        }
        cb(null, data);
      });
      stream.once("error", cb);
      stream.pipe(sink);
      return promise;
    };
  }
});

// ../Server/node_modules/timed-out/index.js
var require_timed_out = __commonJS({
  "../Server/node_modules/timed-out/index.js"(exports, module) {
    "use strict";
    module.exports = function(req, time) {
      if (req.timeoutTimer) {
        return req;
      }
      var delays = isNaN(time) ? time : { socket: time, connect: time };
      var host = req._headers ? " to " + req._headers.host : "";
      if (delays.connect !== void 0) {
        req.timeoutTimer = setTimeout(function timeoutHandler() {
          req.abort();
          var e = new Error("Connection timed out on request" + host);
          e.code = "ETIMEDOUT";
          req.emit("error", e);
        }, delays.connect);
      }
      req.on("socket", function assign(socket) {
        if (!(socket.connecting || socket._connecting)) {
          connect.call(socket);
          return;
        }
        socket.once("connect", connect);
      });
      function clear() {
        if (req.timeoutTimer) {
          clearTimeout(req.timeoutTimer);
          req.timeoutTimer = null;
        }
      }
      function connect() {
        clear();
        if (delays.socket !== void 0) {
          this.setTimeout(delays.socket, function socketTimeoutHandler() {
            req.abort();
            var e = new Error("Socket timed out on request" + host);
            e.code = "ESOCKETTIMEDOUT";
            req.emit("error", e);
          });
        }
      }
      return req.on("error", clear);
    };
  }
});

// ../Server/node_modules/prepend-http/index.js
var require_prepend_http = __commonJS({
  "../Server/node_modules/prepend-http/index.js"(exports, module) {
    "use strict";
    module.exports = function(url) {
      if (typeof url !== "string") {
        throw new TypeError("Expected a string, got " + typeof url);
      }
      url = url.trim();
      if (/^\.*\/|^(?!localhost)\w+:/.test(url)) {
        return url;
      }
      return url.replace(/^(?!(?:\w+:)?\/\/)/, "http://");
    };
  }
});

// ../Server/node_modules/url-parse-lax/index.js
var require_url_parse_lax = __commonJS({
  "../Server/node_modules/url-parse-lax/index.js"(exports, module) {
    "use strict";
    var url = require_url();
    var prependHttp = require_prepend_http();
    module.exports = function(x) {
      var withProtocol = prependHttp(x);
      var parsed = url.parse(withProtocol);
      if (withProtocol !== x) {
        parsed.protocol = null;
      }
      return parsed;
    };
  }
});

// ../Server/node_modules/lowercase-keys/index.js
var require_lowercase_keys = __commonJS({
  "../Server/node_modules/lowercase-keys/index.js"(exports, module) {
    "use strict";
    module.exports = function(obj) {
      var ret = {};
      var keys = Object.keys(Object(obj));
      for (var i = 0; i < keys.length; i++) {
        ret[keys[i].toLowerCase()] = obj[keys[i]];
      }
      return ret;
    };
  }
});

// ../Server/node_modules/is-redirect/index.js
var require_is_redirect = __commonJS({
  "../Server/node_modules/is-redirect/index.js"(exports, module) {
    "use strict";
    module.exports = function(x) {
      if (typeof x !== "number") {
        throw new TypeError("Expected a number");
      }
      return x === 300 || x === 301 || x === 302 || x === 303 || x === 305 || x === 307 || x === 308;
    };
  }
});

// browser-external:unzip-response
var require_unzip_response = __commonJS({
  "browser-external:unzip-response"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "unzip-response" has been externalized for browser compatibility. Cannot access "unzip-response.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../Server/node_modules/capture-stack-trace/index.js
var require_capture_stack_trace = __commonJS({
  "../Server/node_modules/capture-stack-trace/index.js"(exports, module) {
    "use strict";
    module.exports = Error.captureStackTrace || function(error) {
      var container = new Error();
      Object.defineProperty(error, "stack", {
        configurable: true,
        get: function getStack() {
          var stack = container.stack;
          Object.defineProperty(this, "stack", {
            value: stack
          });
          return stack;
        }
      });
    };
  }
});

// ../Server/node_modules/create-error-class/index.js
var require_create_error_class = __commonJS({
  "../Server/node_modules/create-error-class/index.js"(exports, module) {
    "use strict";
    var captureStackTrace = require_capture_stack_trace();
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
    module.exports = function createErrorClass(className, setup) {
      if (typeof className !== "string") {
        throw new TypeError("Expected className to be a string");
      }
      if (/[^0-9a-zA-Z_$]/.test(className)) {
        throw new Error("className contains invalid characters");
      }
      setup = setup || function(message) {
        this.message = message;
      };
      var ErrorClass = function() {
        Object.defineProperty(this, "name", {
          configurable: true,
          value: className,
          writable: true
        });
        captureStackTrace(this, this.constructor);
        setup.apply(this, arguments);
      };
      inherits(ErrorClass, Error);
      return ErrorClass;
    };
  }
});

// ../Server/node_modules/node-status-codes/index.js
var require_node_status_codes = __commonJS({
  "../Server/node_modules/node-status-codes/index.js"(exports, module) {
    "use strict";
    module.exports = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Moved Temporarily",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      308: "Permanent Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Time-out",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Large",
      414: "Request-URI Too Large",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Unordered Collection",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Time-out",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
  }
});

// ../Server/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "../Server/node_modules/is-arrayish/index.js"(exports, module) {
    "use strict";
    module.exports = function isArrayish(obj) {
      if (!obj) {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
    };
  }
});

// ../Server/node_modules/error-ex/index.js
var require_error_ex = __commonJS({
  "../Server/node_modules/error-ex/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var isArrayish = require_is_arrayish();
    var errorEx = function errorEx2(name, properties) {
      if (!name || name.constructor !== String) {
        properties = name || {};
        name = Error.name;
      }
      var errorExError = function ErrorEXError(message) {
        if (!this) {
          return new ErrorEXError(message);
        }
        message = message instanceof Error ? message.message : message || this.message;
        Error.call(this, message);
        Error.captureStackTrace(this, errorExError);
        this.name = name;
        Object.defineProperty(this, "message", {
          configurable: true,
          enumerable: false,
          get: function() {
            var newMessage = message.split(/\r?\n/g);
            for (var key in properties) {
              if (!properties.hasOwnProperty(key)) {
                continue;
              }
              var modifier = properties[key];
              if ("message" in modifier) {
                newMessage = modifier.message(this[key], newMessage) || newMessage;
                if (!isArrayish(newMessage)) {
                  newMessage = [newMessage];
                }
              }
            }
            return newMessage.join("\n");
          },
          set: function(v) {
            message = v;
          }
        });
        var overwrittenStack = null;
        var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
        var stackGetter = stackDescriptor.get;
        var stackValue = stackDescriptor.value;
        delete stackDescriptor.value;
        delete stackDescriptor.writable;
        stackDescriptor.set = function(newstack) {
          overwrittenStack = newstack;
        };
        stackDescriptor.get = function() {
          var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
          if (!overwrittenStack) {
            stack[0] = this.name + ": " + this.message;
          }
          var lineCount = 1;
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("line" in modifier) {
              var line = modifier.line(this[key]);
              if (line) {
                stack.splice(lineCount++, 0, "    " + line);
              }
            }
            if ("stack" in modifier) {
              modifier.stack(this[key], stack);
            }
          }
          return stack.join("\n");
        };
        Object.defineProperty(this, "stack", stackDescriptor);
      };
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(errorExError.prototype, Error.prototype);
        Object.setPrototypeOf(errorExError, Error);
      } else {
        util.inherits(errorExError, Error);
      }
      return errorExError;
    };
    errorEx.append = function(str, def) {
      return {
        message: function(v, message) {
          v = v || def;
          if (v) {
            message[0] += " " + str.replace("%s", v.toString());
          }
          return message;
        }
      };
    };
    errorEx.line = function(str, def) {
      return {
        line: function(v) {
          v = v || def;
          if (v) {
            return str.replace("%s", v.toString());
          }
          return null;
        }
      };
    };
    module.exports = errorEx;
  }
});

// ../Server/node_modules/parse-json/vendor/unicode.js
var require_unicode = __commonJS({
  "../Server/node_modules/parse-json/vendor/unicode.js"(exports, module) {
    var Uni = module.exports;
    module.exports.isWhiteSpace = function isWhiteSpace(x) {
      return x === " " || x === "" || x === "\uFEFF" || x >= "	" && x <= "\r" || x === "" || x === "" || x >= "" && x <= "" || x === "\u2028" || x === "\u2029" || x === "" || x === "" || x === "";
    };
    module.exports.isWhiteSpaceJSON = function isWhiteSpaceJSON(x) {
      return x === " " || x === "	" || x === "\n" || x === "\r";
    };
    module.exports.isLineTerminator = function isLineTerminator(x) {
      return x === "\n" || x === "\r" || x === "\u2028" || x === "\u2029";
    };
    module.exports.isLineTerminatorJSON = function isLineTerminatorJSON(x) {
      return x === "\n" || x === "\r";
    };
    module.exports.isIdentifierStart = function isIdentifierStart(x) {
      return x === "$" || x === "_" || x >= "A" && x <= "Z" || x >= "a" && x <= "z" || x >= "" && Uni.NonAsciiIdentifierStart.test(x);
    };
    module.exports.isIdentifierPart = function isIdentifierPart(x) {
      return x === "$" || x === "_" || x >= "A" && x <= "Z" || x >= "a" && x <= "z" || x >= "0" && x <= "9" || x >= "" && Uni.NonAsciiIdentifierPart.test(x);
    };
    module.exports.NonAsciiIdentifierStart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
    module.exports.NonAsciiIdentifierPart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
  }
});

// ../Server/node_modules/parse-json/vendor/parse.js
var require_parse = __commonJS({
  "../Server/node_modules/parse-json/vendor/parse.js"(exports, module) {
    var Uni = require_unicode();
    function isHexDigit(x) {
      return x >= "0" && x <= "9" || x >= "A" && x <= "F" || x >= "a" && x <= "f";
    }
    function isOctDigit(x) {
      return x >= "0" && x <= "7";
    }
    function isDecDigit(x) {
      return x >= "0" && x <= "9";
    }
    var unescapeMap = {
      "'": "'",
      '"': '"',
      "\\": "\\",
      "b": "\b",
      "f": "\f",
      "n": "\n",
      "r": "\r",
      "t": "	",
      "v": "\v",
      "/": "/"
    };
    function formatError(input, msg, position, lineno, column, json5) {
      var result = msg + " at " + (lineno + 1) + ":" + (column + 1), tmppos = position - column - 1, srcline = "", underline = "";
      var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;
      if (tmppos < position - 70) {
        tmppos = position - 70;
      }
      while (1) {
        var chr = input[++tmppos];
        if (isLineTerminator(chr) || tmppos === input.length) {
          if (position >= tmppos) {
            underline += "^";
          }
          break;
        }
        srcline += chr;
        if (position === tmppos) {
          underline += "^";
        } else if (position > tmppos) {
          underline += input[tmppos] === "	" ? "	" : " ";
        }
        if (srcline.length > 78) break;
      }
      return result + "\n" + srcline + "\n" + underline;
    }
    function parse(input, options) {
      var json5 = !(options.mode === "json" || options.legacy);
      var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;
      var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON;
      var length = input.length, lineno = 0, linestart = 0, position = 0, stack = [];
      var tokenStart = function() {
      };
      var tokenEnd = function(v) {
        return v;
      };
      if (options._tokenize) {
        ;
        (function() {
          var start = null;
          tokenStart = function() {
            if (start !== null) throw Error("internal error, token overlap");
            start = position;
          };
          tokenEnd = function(v, type) {
            if (start != position) {
              var hash = {
                raw: input.substr(start, position - start),
                type,
                stack: stack.slice(0)
              };
              if (v !== void 0) hash.value = v;
              options._tokenize.call(null, hash);
            }
            start = null;
            return v;
          };
        })();
      }
      function fail(msg) {
        var column = position - linestart;
        if (!msg) {
          if (position < length) {
            var token = "'" + JSON.stringify(input[position]).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            if (!msg) msg = "Unexpected token " + token;
          } else {
            if (!msg) msg = "Unexpected end of input";
          }
        }
        var error = SyntaxError(formatError(input, msg, position, lineno, column, json5));
        error.row = lineno + 1;
        error.column = column + 1;
        throw error;
      }
      function newline(chr) {
        if (chr === "\r" && input[position] === "\n") position++;
        linestart = position;
        lineno++;
      }
      function parseGeneric() {
        var result;
        while (position < length) {
          tokenStart();
          var chr = input[position++];
          if (chr === '"' || chr === "'" && json5) {
            return tokenEnd(parseString(chr), "literal");
          } else if (chr === "{") {
            tokenEnd(void 0, "separator");
            return parseObject();
          } else if (chr === "[") {
            tokenEnd(void 0, "separator");
            return parseArray();
          } else if (chr === "-" || chr === "." || isDecDigit(chr) || json5 && (chr === "+" || chr === "I" || chr === "N")) {
            return tokenEnd(parseNumber(), "literal");
          } else if (chr === "n") {
            parseKeyword("null");
            return tokenEnd(null, "literal");
          } else if (chr === "t") {
            parseKeyword("true");
            return tokenEnd(true, "literal");
          } else if (chr === "f") {
            parseKeyword("false");
            return tokenEnd(false, "literal");
          } else {
            position--;
            return tokenEnd(void 0);
          }
        }
      }
      function parseKey() {
        var result;
        while (position < length) {
          tokenStart();
          var chr = input[position++];
          if (chr === '"' || chr === "'" && json5) {
            return tokenEnd(parseString(chr), "key");
          } else if (chr === "{") {
            tokenEnd(void 0, "separator");
            return parseObject();
          } else if (chr === "[") {
            tokenEnd(void 0, "separator");
            return parseArray();
          } else if (chr === "." || isDecDigit(chr)) {
            return tokenEnd(parseNumber(true), "key");
          } else if (json5 && Uni.isIdentifierStart(chr) || chr === "\\" && input[position] === "u") {
            var rollback = position - 1;
            var result = parseIdentifier();
            if (result === void 0) {
              position = rollback;
              return tokenEnd(void 0);
            } else {
              return tokenEnd(result, "key");
            }
          } else {
            position--;
            return tokenEnd(void 0);
          }
        }
      }
      function skipWhiteSpace() {
        tokenStart();
        while (position < length) {
          var chr = input[position++];
          if (isLineTerminator(chr)) {
            position--;
            tokenEnd(void 0, "whitespace");
            tokenStart();
            position++;
            newline(chr);
            tokenEnd(void 0, "newline");
            tokenStart();
          } else if (isWhiteSpace(chr)) {
          } else if (chr === "/" && json5 && (input[position] === "/" || input[position] === "*")) {
            position--;
            tokenEnd(void 0, "whitespace");
            tokenStart();
            position++;
            skipComment(input[position++] === "*");
            tokenEnd(void 0, "comment");
            tokenStart();
          } else {
            position--;
            break;
          }
        }
        return tokenEnd(void 0, "whitespace");
      }
      function skipComment(multi) {
        while (position < length) {
          var chr = input[position++];
          if (isLineTerminator(chr)) {
            if (!multi) {
              position--;
              return;
            }
            newline(chr);
          } else if (chr === "*" && multi) {
            if (input[position] === "/") {
              position++;
              return;
            }
          } else {
          }
        }
        if (multi) {
          fail("Unclosed multiline comment");
        }
      }
      function parseKeyword(keyword) {
        var _pos = position;
        var len = keyword.length;
        for (var i = 1; i < len; i++) {
          if (position >= length || keyword[i] != input[position]) {
            position = _pos - 1;
            fail();
          }
          position++;
        }
      }
      function parseObject() {
        var result = options.null_prototype ? /* @__PURE__ */ Object.create(null) : {}, empty_object = {}, is_non_empty = false;
        while (position < length) {
          skipWhiteSpace();
          var item1 = parseKey();
          skipWhiteSpace();
          tokenStart();
          var chr = input[position++];
          tokenEnd(void 0, "separator");
          if (chr === "}" && item1 === void 0) {
            if (!json5 && is_non_empty) {
              position--;
              fail("Trailing comma in object");
            }
            return result;
          } else if (chr === ":" && item1 !== void 0) {
            skipWhiteSpace();
            stack.push(item1);
            var item2 = parseGeneric();
            stack.pop();
            if (item2 === void 0) fail("No value found for key " + item1);
            if (typeof item1 !== "string") {
              if (!json5 || typeof item1 !== "number") {
                fail("Wrong key type: " + item1);
              }
            }
            if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== "replace") {
              if (options.reserved_keys === "throw") {
                fail("Reserved key: " + item1);
              } else {
              }
            } else {
              if (typeof options.reviver === "function") {
                item2 = options.reviver.call(null, item1, item2);
              }
              if (item2 !== void 0) {
                is_non_empty = true;
                Object.defineProperty(result, item1, {
                  value: item2,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              }
            }
            skipWhiteSpace();
            tokenStart();
            var chr = input[position++];
            tokenEnd(void 0, "separator");
            if (chr === ",") {
              continue;
            } else if (chr === "}") {
              return result;
            } else {
              fail();
            }
          } else {
            position--;
            fail();
          }
        }
        fail();
      }
      function parseArray() {
        var result = [];
        while (position < length) {
          skipWhiteSpace();
          stack.push(result.length);
          var item = parseGeneric();
          stack.pop();
          skipWhiteSpace();
          tokenStart();
          var chr = input[position++];
          tokenEnd(void 0, "separator");
          if (item !== void 0) {
            if (typeof options.reviver === "function") {
              item = options.reviver.call(null, String(result.length), item);
            }
            if (item === void 0) {
              result.length++;
              item = true;
            } else {
              result.push(item);
            }
          }
          if (chr === ",") {
            if (item === void 0) {
              fail("Elisions are not supported");
            }
          } else if (chr === "]") {
            if (!json5 && item === void 0 && result.length) {
              position--;
              fail("Trailing comma in array");
            }
            return result;
          } else {
            position--;
            fail();
          }
        }
      }
      function parseNumber() {
        position--;
        var start = position, chr = input[position++], t;
        var to_num = function(is_octal2) {
          var str = input.substr(start, position - start);
          if (is_octal2) {
            var result = parseInt(str.replace(/^0o?/, ""), 8);
          } else {
            var result = Number(str);
          }
          if (Number.isNaN(result)) {
            position--;
            fail('Bad numeric literal - "' + input.substr(start, position - start + 1) + '"');
          } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {
            position--;
            fail('Non-json numeric literal - "' + input.substr(start, position - start + 1) + '"');
          } else {
            return result;
          }
        };
        if (chr === "-" || chr === "+" && json5) chr = input[position++];
        if (chr === "N" && json5) {
          parseKeyword("NaN");
          return NaN;
        }
        if (chr === "I" && json5) {
          parseKeyword("Infinity");
          return to_num();
        }
        if (chr >= "1" && chr <= "9") {
          while (position < length && isDecDigit(input[position])) position++;
          chr = input[position++];
        }
        if (chr === "0") {
          chr = input[position++];
          var is_octal = chr === "o" || chr === "O" || isOctDigit(chr);
          var is_hex = chr === "x" || chr === "X";
          if (json5 && (is_octal || is_hex)) {
            while (position < length && (is_hex ? isHexDigit : isOctDigit)(input[position])) position++;
            var sign = 1;
            if (input[start] === "-") {
              sign = -1;
              start++;
            } else if (input[start] === "+") {
              start++;
            }
            return sign * to_num(is_octal);
          }
        }
        if (chr === ".") {
          while (position < length && isDecDigit(input[position])) position++;
          chr = input[position++];
        }
        if (chr === "e" || chr === "E") {
          chr = input[position++];
          if (chr === "-" || chr === "+") position++;
          while (position < length && isDecDigit(input[position])) position++;
          chr = input[position++];
        }
        position--;
        return to_num();
      }
      function parseIdentifier() {
        position--;
        var result = "";
        while (position < length) {
          var chr = input[position++];
          if (chr === "\\" && input[position] === "u" && isHexDigit(input[position + 1]) && isHexDigit(input[position + 2]) && isHexDigit(input[position + 3]) && isHexDigit(input[position + 4])) {
            chr = String.fromCharCode(parseInt(input.substr(position + 1, 4), 16));
            position += 5;
          }
          if (result.length) {
            if (Uni.isIdentifierPart(chr)) {
              result += chr;
            } else {
              position--;
              return result;
            }
          } else {
            if (Uni.isIdentifierStart(chr)) {
              result += chr;
            } else {
              return void 0;
            }
          }
        }
        fail();
      }
      function parseString(endChar) {
        var result = "";
        while (position < length) {
          var chr = input[position++];
          if (chr === endChar) {
            return result;
          } else if (chr === "\\") {
            if (position >= length) fail();
            chr = input[position++];
            if (unescapeMap[chr] && (json5 || chr != "v" && chr != "'")) {
              result += unescapeMap[chr];
            } else if (json5 && isLineTerminator(chr)) {
              newline(chr);
            } else if (chr === "u" || chr === "x" && json5) {
              var off = chr === "u" ? 4 : 2;
              for (var i = 0; i < off; i++) {
                if (position >= length) fail();
                if (!isHexDigit(input[position])) fail("Bad escape sequence");
                position++;
              }
              result += String.fromCharCode(parseInt(input.substr(position - off, off), 16));
            } else if (json5 && isOctDigit(chr)) {
              if (chr < "4" && isOctDigit(input[position]) && isOctDigit(input[position + 1])) {
                var digits = 3;
              } else if (isOctDigit(input[position])) {
                var digits = 2;
              } else {
                var digits = 1;
              }
              position += digits - 1;
              result += String.fromCharCode(parseInt(input.substr(position - digits, digits), 8));
            } else if (json5) {
              result += chr;
            } else {
              position--;
              fail();
            }
          } else if (isLineTerminator(chr)) {
            fail();
          } else {
            if (!json5 && chr.charCodeAt(0) < 32) {
              position--;
              fail("Unexpected control character");
            }
            result += chr;
          }
        }
        fail();
      }
      skipWhiteSpace();
      var return_value = parseGeneric();
      if (return_value !== void 0 || position < length) {
        skipWhiteSpace();
        if (position >= length) {
          if (typeof options.reviver === "function") {
            return_value = options.reviver.call(null, "", return_value);
          }
          return return_value;
        } else {
          fail();
        }
      } else {
        if (position) {
          fail("No data, only a whitespace");
        } else {
          fail("No data, empty input");
        }
      }
    }
    module.exports.parse = function parseJSON(input, options) {
      if (typeof options === "function") {
        options = {
          reviver: options
        };
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input !== "string") input = String(input);
      if (options == null) options = {};
      if (options.reserved_keys == null) options.reserved_keys = "ignore";
      if (options.reserved_keys === "throw" || options.reserved_keys === "ignore") {
        if (options.null_prototype == null) {
          options.null_prototype = true;
        }
      }
      try {
        return parse(input, options);
      } catch (err) {
        if (err instanceof SyntaxError && err.row != null && err.column != null) {
          var old_err = err;
          err = SyntaxError(old_err.message);
          err.column = old_err.column;
          err.row = old_err.row;
        }
        throw err;
      }
    };
    module.exports.tokenize = function tokenizeJSON(input, options) {
      if (options == null) options = {};
      options._tokenize = function(smth) {
        if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack);
        tokens.push(smth);
      };
      var tokens = [];
      tokens.data = module.exports.parse(input, options);
      return tokens;
    };
  }
});

// ../Server/node_modules/parse-json/index.js
var require_parse_json = __commonJS({
  "../Server/node_modules/parse-json/index.js"(exports, module) {
    "use strict";
    var errorEx = require_error_ex();
    var fallback = require_parse();
    var JSONError = errorEx("JSONError", {
      fileName: errorEx.append("in %s")
    });
    module.exports = function(x, reviver, filename) {
      if (typeof reviver === "string") {
        filename = reviver;
        reviver = null;
      }
      try {
        try {
          return JSON.parse(x, reviver);
        } catch (err) {
          fallback.parse(x, {
            mode: "json",
            reviver
          });
          throw err;
        }
      } catch (err) {
        var jsonErr = new JSONError(err);
        if (filename) {
          jsonErr.fileName = filename;
        }
        throw jsonErr;
      }
    };
  }
});

// ../Server/node_modules/is-retry-allowed/index.js
var require_is_retry_allowed = __commonJS({
  "../Server/node_modules/is-retry-allowed/index.js"(exports, module) {
    "use strict";
    var WHITELIST = [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "EPIPE",
      "EHOSTUNREACH",
      "EAI_AGAIN"
    ];
    var BLACKLIST = [
      "ENOTFOUND",
      "ENETUNREACH",
      // SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950
      "UNABLE_TO_GET_ISSUER_CERT",
      "UNABLE_TO_GET_CRL",
      "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
      "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
      "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
      "CERT_SIGNATURE_FAILURE",
      "CRL_SIGNATURE_FAILURE",
      "CERT_NOT_YET_VALID",
      "CERT_HAS_EXPIRED",
      "CRL_NOT_YET_VALID",
      "CRL_HAS_EXPIRED",
      "ERROR_IN_CERT_NOT_BEFORE_FIELD",
      "ERROR_IN_CERT_NOT_AFTER_FIELD",
      "ERROR_IN_CRL_LAST_UPDATE_FIELD",
      "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
      "OUT_OF_MEM",
      "DEPTH_ZERO_SELF_SIGNED_CERT",
      "SELF_SIGNED_CERT_IN_CHAIN",
      "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
      "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
      "CERT_CHAIN_TOO_LONG",
      "CERT_REVOKED",
      "INVALID_CA",
      "PATH_LENGTH_EXCEEDED",
      "INVALID_PURPOSE",
      "CERT_UNTRUSTED",
      "CERT_REJECTED"
    ];
    module.exports = function(err) {
      if (!err || !err.code) {
        return true;
      }
      if (WHITELIST.indexOf(err.code) !== -1) {
        return true;
      }
      if (BLACKLIST.indexOf(err.code) !== -1) {
        return false;
      }
      return true;
    };
  }
});

// ../Server/node_modules/got/package.json
var require_package = __commonJS({
  "../Server/node_modules/got/package.json"(exports, module) {
    module.exports = {
      name: "got",
      version: "5.7.1",
      description: "Simplified HTTP/HTTPS requests",
      license: "MIT",
      repository: "sindresorhus/got",
      maintainers: [
        {
          name: "Sindre Sorhus",
          email: "sindresorhus@gmail.com",
          url: "sindresorhus.com"
        },
        {
          name: "Vsevolod Strukchinsky",
          email: "floatdrop@gmail.com",
          url: "github.com/floatdrop"
        }
      ],
      engines: {
        node: ">=0.10.0 <7"
      },
      browser: {
        "unzip-response": false
      },
      scripts: {
        test: "xo && nyc ava",
        coveralls: "nyc report --reporter=text-lcov | coveralls"
      },
      files: [
        "index.js"
      ],
      keywords: [
        "http",
        "https",
        "get",
        "got",
        "url",
        "uri",
        "request",
        "util",
        "utility",
        "simple",
        "curl",
        "wget",
        "fetch"
      ],
      dependencies: {
        "create-error-class": "^3.0.1",
        duplexer2: "^0.1.4",
        "is-redirect": "^1.0.0",
        "is-retry-allowed": "^1.0.0",
        "is-stream": "^1.0.0",
        "lowercase-keys": "^1.0.0",
        "node-status-codes": "^1.0.0",
        "object-assign": "^4.0.1",
        "parse-json": "^2.1.0",
        "pinkie-promise": "^2.0.0",
        "read-all-stream": "^3.0.0",
        "readable-stream": "^2.0.5",
        "timed-out": "^3.0.0",
        "unzip-response": "^1.0.2",
        "url-parse-lax": "^1.0.0"
      },
      devDependencies: {
        ava: "^0.16.0",
        coveralls: "^2.11.4",
        "form-data": "^2.1.1",
        "get-port": "^2.0.0",
        "get-stream": "^2.3.0",
        "into-stream": "^2.0.0",
        nyc: "^8.1.0",
        pem: "^1.4.4",
        pify: "^2.3.0",
        tempfile: "^1.1.1",
        xo: "0.16.x"
      },
      xo: {
        ignores: [
          "test/**"
        ]
      }
    };
  }
});

// ../Server/node_modules/got/index.js
var require_got = __commonJS({
  "../Server/node_modules/got/index.js"(exports, module) {
    "use strict";
    var EventEmitter = require_events().EventEmitter;
    var http = require_http();
    var https = require_https();
    var urlLib = require_url();
    var querystring = require_querystring();
    var objectAssign = require_object_assign();
    var PassThrough = require_readable_browser().PassThrough;
    var duplexer2 = require_duplexer2();
    var isStream = require_is_stream();
    var readAllStream = require_read_all_stream();
    var timedOut = require_timed_out();
    var urlParseLax = require_url_parse_lax();
    var lowercaseKeys = require_lowercase_keys();
    var isRedirect = require_is_redirect();
    var PinkiePromise = require_pinkie_promise();
    var unzipResponse = require_unzip_response();
    var createErrorClass = require_create_error_class();
    var nodeStatusCodes = require_node_status_codes();
    var parseJson = require_parse_json();
    var isRetryAllowed = require_is_retry_allowed();
    var pkg = require_package();
    function requestAsEventEmitter(opts) {
      opts = opts || {};
      var ee = new EventEmitter();
      var requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);
      var redirectCount = 0;
      var retryCount = 0;
      var redirectUrl;
      var get = function(opts2) {
        var fn = opts2.protocol === "https:" ? https : http;
        var req = fn.request(opts2, function(res) {
          var statusCode = res.statusCode;
          if (isRedirect(statusCode) && opts2.followRedirect && "location" in res.headers && (opts2.method === "GET" || opts2.method === "HEAD")) {
            res.resume();
            if (++redirectCount > 10) {
              ee.emit("error", new got.MaxRedirectsError(statusCode, opts2), null, res);
              return;
            }
            redirectUrl = urlLib.resolve(urlLib.format(opts2), res.headers.location);
            var redirectOpts = objectAssign({}, opts2, urlLib.parse(redirectUrl));
            ee.emit("redirect", res, redirectOpts);
            get(redirectOpts);
            return;
          }
          setImmediate(function() {
            var response = typeof unzipResponse === "function" && req.method !== "HEAD" ? unzipResponse(res) : res;
            response.url = redirectUrl || requestUrl;
            response.requestUrl = requestUrl;
            ee.emit("response", response);
          });
        });
        req.once("error", function(err) {
          var backoff = opts2.retries(++retryCount, err);
          if (backoff) {
            setTimeout(get, backoff, opts2);
            return;
          }
          ee.emit("error", new got.RequestError(err, opts2));
        });
        if (opts2.timeout) {
          timedOut(req, opts2.timeout);
        }
        setImmediate(ee.emit.bind(ee), "request", req);
      };
      get(opts);
      return ee;
    }
    function asCallback(opts, cb) {
      var ee = requestAsEventEmitter(opts);
      ee.on("request", function(req) {
        if (isStream(opts.body)) {
          opts.body.pipe(req);
          opts.body = void 0;
          return;
        }
        req.end(opts.body);
      });
      ee.on("response", function(res) {
        readAllStream(res, opts.encoding, function(error, data) {
          var statusCode = res.statusCode;
          var limitStatusCode = opts.followRedirect ? 299 : 399;
          if (error) {
            cb(new got.ReadError(error, opts), null, res);
            return;
          }
          if (statusCode < 200 || statusCode > limitStatusCode) {
            error = new got.HTTPError(statusCode, opts);
          }
          if (opts.json && data) {
            try {
              data = parseJson(data);
            } catch (err) {
              err.fileName = urlLib.format(opts);
              error = new got.ParseError(err, statusCode, opts);
            }
          }
          cb(error, data, res);
        });
      });
      ee.on("error", cb);
    }
    function asPromise(opts) {
      return new PinkiePromise(function(resolve, reject) {
        asCallback(opts, function(err, data, response) {
          if (response) {
            response.body = data;
          }
          if (err) {
            Object.defineProperty(err, "response", {
              value: response,
              enumerable: false
            });
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    }
    function asStream(opts) {
      var input = new PassThrough();
      var output = new PassThrough();
      var proxy = duplexer2(input, output);
      if (opts.json) {
        throw new Error("got can not be used as stream when options.json is used");
      }
      if (opts.body) {
        proxy.write = function() {
          throw new Error("got's stream is not writable when options.body is used");
        };
      }
      var ee = requestAsEventEmitter(opts);
      ee.on("request", function(req) {
        proxy.emit("request", req);
        if (isStream(opts.body)) {
          opts.body.pipe(req);
          return;
        }
        if (opts.body) {
          req.end(opts.body);
          return;
        }
        if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
          input.pipe(req);
          return;
        }
        req.end();
      });
      ee.on("response", function(res) {
        var statusCode = res.statusCode;
        var limitStatusCode = opts.followRedirect ? 299 : 399;
        res.pipe(output);
        if (statusCode < 200 || statusCode > limitStatusCode) {
          proxy.emit("error", new got.HTTPError(statusCode, opts), null, res);
          return;
        }
        proxy.emit("response", res);
      });
      ee.on("redirect", proxy.emit.bind(proxy, "redirect"));
      ee.on("error", proxy.emit.bind(proxy, "error"));
      return proxy;
    }
    function normalizeArguments(url, opts) {
      if (typeof url !== "string" && typeof url !== "object") {
        throw new Error("Parameter `url` must be a string or object, not " + typeof url);
      }
      if (typeof url === "string") {
        url = url.replace(/^unix:/, "http://$&");
        url = urlParseLax(url);
        if (url.auth) {
          throw new Error("Basic authentication must be done with auth option");
        }
      }
      opts = objectAssign(
        { protocol: "http:", path: "", retries: 5 },
        url,
        opts
      );
      opts.headers = objectAssign({
        "user-agent": pkg.name + "/" + pkg.version + " (https://github.com/sindresorhus/got)",
        "accept-encoding": "gzip,deflate"
      }, lowercaseKeys(opts.headers));
      var query = opts.query;
      if (query) {
        if (typeof query !== "string") {
          opts.query = querystring.stringify(query);
        }
        opts.path = opts.path.split("?")[0] + "?" + opts.query;
        delete opts.query;
      }
      if (opts.json && opts.headers.accept === void 0) {
        opts.headers.accept = "application/json";
      }
      var body = opts.body;
      if (body) {
        if (typeof body !== "string" && !(body !== null && typeof body === "object")) {
          throw new Error("options.body must be a ReadableStream, string, Buffer or plain Object");
        }
        opts.method = opts.method || "POST";
        if (isStream(body) && typeof body.getBoundary === "function") {
          opts.headers["content-type"] = opts.headers["content-type"] || "multipart/form-data; boundary=" + body.getBoundary();
        } else if (body !== null && typeof body === "object" && !Buffer.isBuffer(body) && !isStream(body)) {
          opts.headers["content-type"] = opts.headers["content-type"] || "application/x-www-form-urlencoded";
          body = opts.body = querystring.stringify(body);
        }
        if (opts.headers["content-length"] === void 0 && opts.headers["transfer-encoding"] === void 0 && !isStream(body)) {
          var length = typeof body === "string" ? Buffer.byteLength(body) : body.length;
          opts.headers["content-length"] = length;
        }
      }
      opts.method = opts.method || "GET";
      opts.method = opts.method.toUpperCase();
      if (opts.hostname === "unix") {
        var matches = /(.+):(.+)/.exec(opts.path);
        if (matches) {
          opts.socketPath = matches[1];
          opts.path = matches[2];
          opts.host = null;
        }
      }
      if (typeof opts.retries !== "function") {
        var retries = opts.retries;
        opts.retries = function backoff(iter, err) {
          if (iter > retries || !isRetryAllowed(err)) {
            return 0;
          }
          var noise = Math.random() * 100;
          return (1 << iter) * 1e3 + noise;
        };
      }
      if (opts.followRedirect === void 0) {
        opts.followRedirect = true;
      }
      return opts;
    }
    function got(url, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      if (cb) {
        asCallback(normalizeArguments(url, opts), cb);
        return null;
      }
      try {
        return asPromise(normalizeArguments(url, opts));
      } catch (err) {
        return PinkiePromise.reject(err);
      }
    }
    var helpers = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    helpers.forEach(function(el) {
      got[el] = function(url, opts, cb) {
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        return got(url, objectAssign({}, opts, { method: el }), cb);
      };
    });
    got.stream = function(url, opts, cb) {
      if (cb || typeof opts === "function") {
        throw new Error("callback can not be used with stream mode");
      }
      return asStream(normalizeArguments(url, opts));
    };
    helpers.forEach(function(el) {
      got.stream[el] = function(url, opts, cb) {
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        return got.stream(url, objectAssign({}, opts, { method: el }), cb);
      };
    });
    function stdError(error, opts) {
      if (error.code !== void 0) {
        this.code = error.code;
      }
      objectAssign(this, {
        message: error.message,
        host: opts.host,
        hostname: opts.hostname,
        method: opts.method,
        path: opts.path
      });
    }
    got.RequestError = createErrorClass("RequestError", stdError);
    got.ReadError = createErrorClass("ReadError", stdError);
    got.ParseError = createErrorClass("ParseError", function(e, statusCode, opts) {
      stdError.call(this, e, opts);
      this.statusCode = statusCode;
      this.statusMessage = nodeStatusCodes[this.statusCode];
    });
    got.HTTPError = createErrorClass("HTTPError", function(statusCode, opts) {
      stdError.call(this, {}, opts);
      this.statusCode = statusCode;
      this.statusMessage = nodeStatusCodes[this.statusCode];
      this.message = "Response code " + this.statusCode + " (" + this.statusMessage + ")";
    });
    got.MaxRedirectsError = createErrorClass("MaxRedirectsError", function(statusCode, opts) {
      stdError.call(this, {}, opts);
      this.statusCode = statusCode;
      this.statusMessage = nodeStatusCodes[this.statusCode];
      this.message = "Redirected 10 times. Aborting.";
    });
    module.exports = got;
  }
});

// ../Server/node_modules/textract/lib/index.js
var require_lib = __commonJS({
  "../Server/node_modules/textract/lib/index.js"(exports, module) {
    var fs = require_fs();
    var path = require_path();
    var mime = require_mime();
    var extract = require_extract();
    var os = require_os();
    var got = require_got();
    var tmpDir = os.tmpdir();
    function _genRandom() {
      return Math.floor(Math.random() * 1e11 + 1);
    }
    function _extractWithType(type, filePath, options, cb) {
      fs.exists(filePath, function(exists) {
        if (exists) {
          extract(type, filePath, options, cb);
        } else {
          cb(new Error("File at path [[ " + filePath + " ]] does not exist."), null);
        }
      });
    }
    function _returnArgsError(_args) {
      var args = Array.prototype.slice.call(_args), callback;
      args.forEach(function(parm) {
        if (parm && typeof parm === "function") {
          callback = parm;
        }
      });
      if (callback) {
        callback(new Error("Incorrect parameters passed to textract."), null);
      } else {
        console.error("textract could not find a callback function to execute.");
      }
    }
    function _writeBufferToDisk(buff, cb) {
      var fullPath = path.join(tmpDir, "textract_file_" + _genRandom());
      fs.open(fullPath, "w", function(err, fd) {
        if (err) {
          throw new Error("error opening temp file: " + err);
        } else {
          fs.write(fd, buff, 0, buff.length, null, function(err2) {
            if (err2) {
              throw new Error("error writing temp file: " + err2);
            } else {
              fs.close(fd, function() {
                cb(fullPath);
              });
            }
          });
        }
      });
    }
    function fromFileWithMimeAndPath(type, filePath, options, cb) {
      var called = false;
      if (typeof type === "string" && typeof filePath === "string") {
        if (typeof cb === "function" && typeof options === "object") {
          _extractWithType(type, filePath, options, cb);
          called = true;
        } else if (typeof options === "function" && cb === void 0) {
          _extractWithType(type, filePath, {}, options);
          called = true;
        }
      }
      if (!called) {
        _returnArgsError(arguments);
      }
    }
    function fromFileWithPath(filePath, options, cb) {
      var type;
      if (typeof filePath === "string" && (typeof options === "function" || typeof cb === "function")) {
        type = options && options.typeOverride || mime.getType(filePath);
        fromFileWithMimeAndPath(type, filePath, options, cb);
      } else {
        _returnArgsError(arguments);
      }
    }
    function fromBufferWithMime(type, bufferContent, options, cb, withPath) {
      if (typeof type === "string" && bufferContent && bufferContent instanceof Buffer && (typeof options === "function" || typeof cb === "function")) {
        _writeBufferToDisk(bufferContent, function(newPath) {
          fromFileWithMimeAndPath(type, newPath, options, cb);
        });
      } else {
        _returnArgsError(arguments);
      }
    }
    function fromBufferWithName(filePath, bufferContent, options, cb) {
      var type;
      if (typeof filePath === "string") {
        type = mime.getType(filePath);
        fromBufferWithMime(type, bufferContent, options, cb, true);
      } else {
        _returnArgsError(arguments);
      }
    }
    function fromUrl(url, options, cb) {
      var urlNoQueryParams, extname, filePath, fullFilePath, file, href, callbackCalled;
      href = typeof url === "string" ? url : url.href;
      if (href) {
        options = options || {};
        urlNoQueryParams = href.split("?")[0];
        extname = path.extname(urlNoQueryParams);
        filePath = _genRandom() + extname;
        fullFilePath = path.join(tmpDir, filePath);
        file = fs.createWriteStream(fullFilePath);
        file.on("finish", function() {
          if (!callbackCalled) {
            fromFileWithPath(fullFilePath, options, cb);
          }
        });
        got.stream(url).on("response", function(response) {
          if (!options.typeOverride) {
            options.typeOverride = response.headers["content-type"].split(/;/)[0];
          }
        }).on("error", function(error) {
          var _cb = typeof options === "function" ? options : cb;
          callbackCalled = true;
          _cb(error);
        }).pipe(file);
      } else {
        _returnArgsError(arguments);
      }
    }
    module.exports = {
      fromFileWithPath,
      fromFileWithMimeAndPath,
      fromBufferWithName,
      fromBufferWithMime,
      fromUrl
    };
  }
});
export default require_lib();
//# sourceMappingURL=textract.js.map
